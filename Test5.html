<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Random Symmetric Lodge</title>
<style>
body { display:flex; flex-direction:column; align-items:center; font-family:sans-serif; background:#f0f0f0; }
#board { position:relative; width:800px; height:700px; margin-top:20px; }
.hex { position:absolute; width:80px; height:70px;
       clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
       display:flex; align-items:center; justify-content:center; color:white;
       font-size:12px; text-align:center; border:2px solid #333; box-sizing:border-box; }
.black { background:#000; } .purple { background:purple; } .red { background:red; } .green { background:green; }
.blue { background:blue; } .gray { background:gray; } .yellow { background:goldenrod; }
.throne { border:3px solid gold; }
button { margin-top:20px; padding:10px 20px; font-size:16px; }
</style>
</head>
<body>
<h1>Random Symmetric Lodge Generator</h1>
<button onclick="generateLodge()">Regenerate Lodge</button>
<div id="board"></div>
<script>
const hexSize = 40, sqrt3 = Math.sqrt(3);
const directions = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];

function key(q,r){ return `${q},${r}`; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
function neighbors(tile,map){ return directions.map(([dq,dr])=>map[key(tile.q+dq,tile.r+dr)]).filter(t=>t); }

// --- 1. Build symmetric tile positions ---
function buildRandomSymmetricShape(){
    const tilesMap = {};
    const tiles = [{q:0,r:0}]; 
    tilesMap[key(0,0)] = tiles[0];
    let frontier = [[1,0]]; // start first ring

    while(tiles.length < 19){
        if(frontier.length === 0) break;
        const idx = Math.floor(Math.random() * frontier.length);
        const [q,r] = frontier.splice(idx,1)[0];
        const mirror = [-q,-r];
        [[q,r], mirror].forEach(([mq,mr])=>{
            const k = key(mq,mr);
            if(!tilesMap[k] && tiles.length < 19){
                let tile = {q:mq,r:mr};
                tiles.push(tile);
                tilesMap[k] = tile;
                directions.forEach(([dq,dr])=>{
                    const nk = key(mq+dq,mr+dr);
                    if(!tilesMap[nk]) frontier.push([mq+dq,mr+dr]);
                });
            }
        });
    }
    return tiles.slice(0,19);
}

// --- 2. Assign colors with adjacency constraints ---
function assignColors(tiles){
    const counts = {black:1,purple:3,red:3,green:3,blue:3,gray:3,yellow:3};
    let map = {}; tiles.forEach(t=>map[key(t.q,t.r)] = t);

    // order by descending degree
    let order = tiles.slice().sort((a,b)=>neighbors(b,map).length - neighbors(a,map).length);
    order[0].color = "black"; counts.black--;

    // throne randomly in first ring
    let ring1 = neighbors(order[0], map);
    let throne = ring1[Math.floor(Math.random()*ring1.length)];
    throne.color = "purple"; counts.purple--;

    function bt(idx){
        if(idx === order.length) return true;
        let t = order[idx]; if(t.color) return bt(idx+1);
        for(let color in counts){
            if(counts[color] <= 0) continue;
            if(neighbors(t,map).some(n=>n.color===color)) continue;
            t.color = color; counts[color]--; if(bt(idx+1)) return true; t.color=null; counts[color]++;
        }
        return false;
    }
    if(!bt(0)) throw new Error("Color assignment failed");
    return tiles;
}

// --- 3. Assign 19 unique rooms ---
function assignRoomsUnique(tiles){
    const fixedRooms = {black:"Black Rose Room", purple:"Throne Room"};
    let otherRooms = [];
    const colorCounts = {purple:2, red:3, green:3, blue:3, gray:3, yellow:3}; // remaining counts after fixed
    for(let c in colorCounts){
        for(let i=1;i<=colorCounts[c];i++) otherRooms.push(`${c.charAt(0).toUpperCase()+c.slice(1)} Room ${i}`);
    }
    shuffle(otherRooms);

    tiles.forEach(t=>{
        if(t.color==="black") t.room = fixedRooms.black;
        else if(t.color==="purple" && !t.room) t.room = fixedRooms.purple;
        else t.room = otherRooms.pop();
    });
}

// --- 4. Render ---
function renderLodge(tiles){
    const board = document.getElementById("board"); board.innerHTML="";
    const offsetX = board.offsetWidth/2, offsetY = board.offsetHeight/2;
    tiles.forEach(t=>{
        const x = offsetX + hexSize*3/2*t.q;
        const y = offsetY + hexSize*sqrt3*(t.r + t.q/2);
        const div = document.createElement("div");
        div.className = "hex " + t.color;
        if(t.color==="purple" && t.room.includes("Throne")) div.classList.add("throne");
        div.style.left = (x-hexSize)+"px";
        div.style.top = (y-hexSize)+"px";
        div.innerHTML = t.room;
        board.appendChild(div);
    });
}

// --- 5. Main ---
function generateLodge(){
    let tiles = buildRandomSymmetricShape();
    tiles = assignColors(tiles);
    assignRoomsUnique(tiles);
    renderLodge(tiles);
}

generateLodge();
</script>
</body>
</html>

