<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagonal Game Board</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            margin: 0;
            flex-direction: column;
            font-family: sans-serif;
            color: #eee;
        }
        #game-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        .hex-row {
            display: flex;
            justify-content: center;
        }
        .hex-row:nth-child(even) {
            margin-left: 46px; /* Correct offset for 80px wide hexes */
        }
        .hexagon {
            width: 80px;
            height: 92px;
            position: relative;
            background: #555;
            margin: 0 4px; /* Space between hexes */
            margin-top: -23px; /* Correct overlap */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            text-align: center;
            box-sizing: border-box;
            border: 2px solid #444;
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }
        .hex-row:first-child .hexagon {
            margin-top: 0;
        }
        .black-rose {
            background-color: #000;
            border-color: #f00;
            color: #f00;
        }
        .throne-room {
            background-color: #a0a;
            border-color: #fff;
            color: #fff;
            font-weight: bold;
        }
        .red { background-color: #a00; }
        .green { background-color: #0a0; }
        .yellow { background-color: #aa0; }
        .blue { background-color: #00a; }
        .purple { background-color: #a0a; }
        .gray { background-color: #777; }
        .button-container {
            margin-top: 30px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #555;
            color: #eee;
            border: 1px solid #777;
            border-radius: 5px;
        }
        button:hover {
            background-color: #777;
        }
    </style>
</head>
<body>

    <h1>Random Symmetric Lodge</h1>
    <div id="game-board"></div>
    <div class="button-container">
        <button id="recreate-button">Recreate Lodge</button>
    </div>

    <script>
        // Fisher-Yates shuffle algorithm
        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex != 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        // Axial directions
        const directions = [
            {q: 1, r: 0}, {q: -1, r: 0}, {q: 0, r: 1}, {q: 0, r: -1},
            {q: 1, r: -1}, {q: -1, r: 1}
        ];

        function getNeighbors(room, allRooms) {
            const neighbors = [];
            for (const dir of directions) {
                const neighbor = allRooms.find(r => r.q === room.q + dir.q && r.r === room.r + dir.r);
                if (neighbor) {
                    neighbors.push(neighbor);
                }
            }
            return neighbors;
        }

        function isConnected(rooms) {
            if (rooms.length === 0) return true;
            const visited = new Set();
            const queue = [rooms[0]];
            visited.add(`${rooms[0].q},${rooms[0].r}`);

            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = getNeighbors(current, rooms);
                for (const neighbor of neighbors) {
                    const coordString = `${neighbor.q},${neighbor.r}`;
                    if (!visited.has(coordString)) {
                        visited.add(coordString);
                        queue.push(neighbor);
                    }
                }
            }
            return visited.size === rooms.length;
        }
        
        // Backtracking algorithm for color assignment
        function solveColoring(rooms, roomIndex, colorPool) {
            if (roomIndex === rooms.length) {
                return true; // All rooms successfully colored
            }

            const room = rooms[roomIndex];
            const availableColors = [...colorPool];
            shuffle(availableColors);

            for (const color of availableColors) {
                const isAdjacentSameColor = getNeighbors(room, rooms).some(neighbor => neighbor.color === color);
                
                if (!isAdjacentSameColor && colorPool.includes(color)) {
                    room.color = color;
                    const colorIndex = colorPool.indexOf(color);
                    colorPool.splice(colorIndex, 1);

                    if (solveColoring(rooms, roomIndex + 1, colorPool)) {
                        return true;
                    }

                    // Backtrack
                    room.color = null;
                    colorPool.push(color);
                }
            }
            return false;
        }

        function createBoard() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';
            
            let rooms = [];
            let validConfiguration = false;
            let attemptCount = 0;
            const maxAttempts = 2000;

            while (!validConfiguration && attemptCount < maxAttempts) {
                rooms = [];
                const roomCoordinates = new Set();
                
                // 1. Place the Black Rose and its 6 adjacent rooms
                const blackRosePos = {q: 0, r: 0};
                rooms.push({q: blackRosePos.q, r: blackRosePos.r, color: 'black-rose', name: 'Black Rose Room'});
                roomCoordinates.add(JSON.stringify(blackRosePos));
                
                for (const dir of directions) {
                    rooms.push({q: dir.q, r: dir.r, color: null, name: null});
                    roomCoordinates.add(JSON.stringify({q: dir.q, r: dir.r}));
                }

                // 2. Find all possible symmetric pairs within a distance of 3
                const possibleSymmetricPairs = [];
                for (let q = -3; q <= 3; q++) {
                    for (let r = -3; r <= 3; r++) {
                        const s = -q - r;
                        if (Math.abs(q) + Math.abs(r) + Math.abs(s) > 6) continue;
                        const pos1 = {q: q, r: r};
                        const pos2 = {q: -q, r: -r};

                        if (!roomCoordinates.has(JSON.stringify(pos1)) && !roomCoordinates.has(JSON.stringify(pos2))) {
                            if (q > 0 || (q === 0 && r > 0)) {
                                possibleSymmetricPairs.push([pos1, pos2]);
                            }
                        }
                    }
                }
                
                // 3. Select 6 random symmetric pairs for the remaining 12 rooms
                shuffle(possibleSymmetricPairs);
                const selectedPairs = possibleSymmetricPairs.slice(0, 6);
                selectedPairs.forEach(pair => {
                    rooms.push({q: pair[0].q, r: pair[0].r, color: null, name: null});
                    rooms.push({q: pair[1].q, r: pair[1].r, color: null, name: null});
                });
                
                // 4. Check for connectivity and color assignment
                if (isConnected(rooms)) {
                    const throneRoom = shuffle(getNeighbors({q: 0, r: 0}, rooms))[0];
                    throneRoom.color = 'purple';
                    throneRoom.name = 'Throne Room';

                    const colorPool = [];
                    for (const color of ['red', 'green', 'yellow', 'blue', 'purple', 'gray']) {
                        if (color === 'purple') {
                            colorPool.push('purple', 'purple');
                        } else {
                            colorPool.push(color, color, color);
                        }
                    }
                    
                    const remainingRooms = rooms.filter(r => r.color === null);
                    
                    if (solveColoring(remainingRooms, 0, colorPool)) {
                        validConfiguration = true;
                    }
                }
                attemptCount++;
            }

            if (!validConfiguration) {
                 console.error(`Could not find a valid configuration after ${maxAttempts} attempts.`);
                 return;
            } else {
                console.log(`Successfully generated a valid board after ${attemptCount} attempts.`);
            }

            // 5. Render the board
            const hexRows = {};
            for (const room of rooms) {
                const row = room.r;
                if (!hexRows[row]) {
                    hexRows[row] = [];
                }
                hexRows[row].push(room);
            }

            const sortedRows = Object.keys(hexRows).sort((a, b) => a - b);
            
            for (const row of sortedRows) {
                const hexRowDiv = document.createElement('div');
                hexRowDiv.classList.add('hex-row');
                
                const sortedRooms = hexRows[row].sort((a, b) => a.q - b.q);
                for (const room of sortedRooms) {
                    const hexagon = document.createElement('div');
                    hexagon.classList.add('hexagon');
                    
                    hexagon.textContent = room.name.includes('Room') ? room.name.replace('Room - ', '') : room.name;

                    if (room.color === 'black-rose') {
                        hexagon.classList.add('black-rose');
                    } else if (room.name === 'Throne Room') {
                        hexagon.classList.add('throne-room');
                    } else {
                        hexagon.classList.add(room.color);
                    }
                    hexRowDiv.appendChild(hexagon);
                }
                gameBoard.appendChild(hexRowDiv);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            createBoard();
            document.getElementById('recreate-button').addEventListener('click', createBoard);
        });
    </script>

</body>
</html>
