<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lodge Generator</title>
<style>
  #board { position:relative; width:100%; height:600px; background:#eee; }
  .hex {
    position:absolute;
    width:60px; height:52px;
    background:#ccc;
    clip-path:polygon(50% 0%,100% 25%,100% 75%,50% 100%,0% 75%,0% 25%);
    display:flex; align-items:center; justify-content:center;
    font-size:10px; text-align:center; border:1px solid #333;
  }
  .hex.black{background:#000;color:#fff;}
  .hex.purple{background:purple;color:#fff;}
  .hex.red{background:red;color:#fff;}
  .hex.green{background:green;color:#fff;}
  .hex.blue{background:blue;color:#fff;}
  .hex.gray{background:gray;color:#fff;}
  .hex.yellow{background:yellow;color:#000;}
  .hex.throne{border:3px solid gold;}
  .label{pointer-events:none;font-size:8px;text-align:center;}
</style>
</head>
<body>
<div id="board"></div>

<script>
/* ===== helper functions ===== */
function key(q,r){return `${q},${r}`;}
function unkey(k){const [q,r]=k.split(',').map(Number);return {q,r};}
function axialToPixel(q,r){const HEX_W=60, HEX_H=52; return {x:HEX_W*3/2*q, y:HEX_H*(Math.sqrt(3)/2*q+r)};}

/* ===== lodge rooms ===== */
const rooms = [
  "Black Rose Room|black", "Throne Room|purple",
  "Room1|purple","Room2|purple","Room3|purple",
  "Room1|red","Room2|red","Room3|red",
  "Room1|green","Room2|green","Room3|green",
  "Room1|blue","Room2|blue","Room3|blue",
  "Room1|gray","Room2|gray","Room3|gray",
  "Room1|yellow","Room2|yellow","Room3|yellow"
];
const COLOR_COUNTS = { black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3 };

/* ===== build full 37-hex set ===== */
function buildFullSet(){
  const s = new Set();
  for(let q=-3;q<=3;q++){
    for(let r=Math.max(-3,-q-3); r<=Math.min(3,-q+3); r++){
      s.add(key(q,r));
    }
  }
  return s;
}

/* ===== adjacency map ===== */
function buildAdjMap(shape){
  const adj = new Map();
  const dirs = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  for(const k of shape){
    const {q,r}=unkey(k);
    adj.set(k,[]);
    for(const [dq,dr] of dirs){
      const nk = key(q+dq,r+dr);
      if(shape.has(nk)) adj.get(k).push(nk);
    }
  }
  return adj;
}

/* ===== connectivity & min-degree ===== */
function isConnected(shape){
  if(shape.size===0) return true;
  const adj=buildAdjMap(shape);
  const start = shape.values().next().value;
  const seen = new Set();
  const stack=[start];
  while(stack.length){
    const n=stack.pop();
    if(seen.has(n)) continue;
    seen.add(n);
    for(const nn of adj.get(n)) stack.push(nn);
  }
  return seen.size===shape.size;
}
function minDegreeAtLeast(shape,minD){
  const adj=buildAdjMap(shape);
  for(const [k,v] of adj) if(v.length<minD) return false;
  return true;
}

/* ===== hole check ===== */
function holeNeighborCounts(fullSet,shape){
  let holes4=0, holes5plus=0;
  const dirs=[[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  for(const k of fullSet){
    if(shape.has(k)) continue;
    const {q,r}=unkey(k);
    let cnt=0;
    for(const [dq,dr] of dirs){
      if(shape.has(key(q+dq,r+dr))) cnt++;
    }
    if(cnt===4) holes4++;
    if(cnt>=5) holes5plus++;
  }
  return {holes4,holes5plus};
}

/* ===== distance from center ===== */
function distanceFromCenter(k){ const {q,r}=unkey(k); return Math.max(Math.abs(q),Math.abs(r),Math.abs(-q-r)); }

/* ===== shuffle ===== */
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}

/* ===== build candidate pairs ===== */
function buildCandidatePairs(fullSet){
  const arr=[...fullSet];
  const pairs=[];
  for(let i=0;i<arr.length;i++){
    for(let j=i+1;j<arr.length;j++){
      pairs.push([arr[i],arr[j]]);
    }
  }
  return pairs;
}

/* ===== choose removal pairs with distance pruning ===== */
function chooseRemovalPairCombination(fullSet,candidates,removePairsNeeded){
  const totalPairs=candidates.length;
  let result=null;
  shuffle(candidates);
  const selected=[];
  function buildShape(sel){
    const shape=new Set(fullSet);
    for(const [a,b] of sel){ shape.delete(a); shape.delete(b); }
    return shape;
  }
  function quickPrune(sel){
    const shape=buildShape(sel);
    if(!isConnected(shape)) return false;
    if(!minDegreeAtLeast(shape,2)) return false;
    const {holes5plus}=holeNeighborCounts(fullSet,shape);
    if(holes5plus>0) return false;
    for(const k of shape) if(distanceFromCenter(k)>3) return false;
    return true;
  }
  function backtrack(startIdx){
    if(result) return true;
    if(selected.length===removePairsNeeded){
      const finalShape=buildShape(selected);
      result=finalShape; return true;
    }
    if(startIdx>=totalPairs) return false;
    const remainingNeeded=removePairsNeeded-selected.length;
    if(totalPairs-startIdx<remainingNeeded) return false;
    for(let i=startIdx;i<totalPairs;i++){
      selected.push(candidates[i]);
      if(quickPrune(selected)) if(backtrack(i+1)) return true;
      selected.pop();
    }
    return false;
  }
  backtrack(0);
  return result;
}

/* ===== ring keys (for throne) ===== */
function ringKeys(radius){
  const keys=[];
  for(let q=-radius;q<=radius;q++){
    for(let r=Math.max(-radius,-q-radius);r<=Math.min(radius,-q+radius);r++){
      keys.push(key(q,r));
    }
  }
  return keys;
}

/* ===== assign colors ===== */
function assignColorsToShape(shapeSet,throneKey){
  const adj=buildAdjMap(shapeSet);
  const nodes=[...shapeSet];
  const colorOf=new Map();
  const counts=JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  colorOf.set(throneKey,'purple'); counts.purple--;
  const toColor=nodes.filter(n=>n!==key(0,0)&&n!==throneKey).sort((a,b)=>adj.get(b).length-adj.get(a).length);
  function backtrack(i){
    if(i>=toColor.length) return true;
    const node=toColor[i];
    const used=new Set(adj.get(node).map(n=>colorOf.get(n)).filter(Boolean));
    const candidates=Object.keys(counts).filter(c=>counts[c]>0&&!used.has(c));
    shuffle(candidates);
    for(const c of candidates){
      colorOf.set(node,c); counts[c]--;
      if(backtrack(i+1)) return true;
      counts[c]++; colorOf.delete(node);
    }
    return false;
  }
  return backtrack(0)?colorOf:null;
}

/* ===== map rooms ===== */
function mapRoomsToPositions(colorMap,throneKey){
  const pools={};
  for(const s of rooms){
    const [name,col]=s.split('|').map(x=>x.trim());
    if(!pools[col]) pools[col]=[];
    pools[col].push(name);
  }
  for(const col of Object.keys(pools)) shuffle(pools[col]);
  const mapping=new Map();
  // center
  mapping.set(key(0,0),{name:'Black Rose Room',color:'black'});
  pools.black=pools.black.filter(n=>n!=='Black Rose Room');
  // throne
  mapping.set(throneKey,{name:'Throne Room',color:'purple'});
  pools.purple=pools.purple.filter(n=>n!=='Throne Room');
  // other positions
  const otherPositions=[...colorMap.keys()].filter(k=>k!==key(0,0)&&k!==throneKey);
  shuffle(otherPositions);
  for(const pos of otherPositions){
    const col=colorMap.get(pos);
    mapping.set(pos,{name:pools[col].pop(),color:col});
  }
  return mapping;
}

/* ===== render ===== */
function renderLodge(mapping){
  const board=document.getElementById('board');
  board.innerHTML='';
  for(const [k,v] of mapping){
    const {x,y}=axialToPixel(...k.split(',').map(Number));
    const div=document.createElement('div');
    div.className='hex '+v.color+(v.name==='Throne Room'?' throne':'');
    div.style.left=(x+300)+'px'; div.style.top=(y+200)+'px';
    div.innerHTML=v.name.split(' ')[0];
    board.appendChild(div);
  }
}

/* ===== generate valid lodge ===== */
function generateValidLodge(){
  const fullSet=buildFullSet();
  const candidates=buildCandidatePairs(fullSet);
  let shape=null;
  while(!shape){
    shape=chooseRemovalPairCombination(fullSet,candidates,9); // remove 18 to get 19
  }
  // throne: choose randomly from ring 1
  const ring1=ringKeys(1).filter(k=>shape.has(k));
  const throneKey=ring1[Math.floor(Math.random()*ring1.length)];
  const colorMap=assignColorsToShape(shape,throneKey);
  const mapping=mapRoomsToPositions(colorMap,throneKey);
  return mapping;
}

/* ===== run ===== */
const lodge=generateValidLodge();
renderLodge(lodge);

</script>
</body>
</html>
