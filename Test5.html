<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lodge Generator</title>
<style>
  #board { position: relative; width: 800px; height: 600px; background: #f0f0f0; margin: 20px auto; }
  .hex { position: absolute; width: 70px; height: 60px; background: lightgray; clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); display:flex; align-items:center; justify-content:center; text-align:center; font-size:10px; }
  .black { background: black; color: white; }
  .purple { background: purple; color: white; }
  .red { background: red; color: white; }
  .green { background: green; color: white; }
  .blue { background: blue; color: white; }
  .gray { background: gray; color: white; }
  .yellow { background: yellow; color: black; }
  .throne { border: 3px solid gold; }
  .label { pointer-events: none; }
  #regen { display:block; margin:10px auto; padding:5px 10px; }
</style>
</head>
<body>
<button id="regen">Regenerate Lodge</button>
<div id="board"></div>
<script>
// ===== Hex helpers =====
const HEX_W = 70, HEX_H = 60;
function axialToPixel(q,r) { return { x: HEX_W * 3/4 * q, y: HEX_H * (r + q/2) }; }
function key(q,r){ return `${q},${r}`; }
function unkey(k){ const [q,r] = k.split(',').map(Number); return {q,r}; }
function neighbors(q,r){ return [[q+1,r],[q-1,r],[q,r+1],[q,r-1],[q+1,r-1],[q-1,r+1]]; }

// ===== Parameters =====
const TOTAL_TILES = 19;
const COLOR_COUNTS = { black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3 };
const rooms = [
  "Black Rose Room|black",
  "Throne Room|purple", "Library|purple","Chapel|purple",
  "Armory|red","Barracks|red","Forge|red",
  "Garden|green","Orchard|green","Gallery|green",
  "Workshop|blue","Laboratory|blue","Observatory|blue",
  "Vault|gray","Store|gray","Cellar|gray",
  "Guest Room|yellow","Dining Hall|yellow","Kitchen|yellow"
];

// ===== Generate shape safely =====
function generateShape() {
  let shape = new Set([key(0,0)]); // Black Rose center
  let frontier = [[0,0]];
  while(shape.size < TOTAL_TILES && frontier.length){
    const idx = Math.floor(Math.random() * frontier.length);
    const [q,r] = frontier.splice(idx,1)[0];
    for(const [nq,nr] of neighbors(q,r)){
      const nk = key(nq,nr);
      if(shape.has(nk)) continue;
      if(Math.abs(nq) > 3 || Math.abs(nr) > 3 || Math.abs(nq+nr) > 3) continue;
      shape.add(nk);
      frontier.push([nq,nr]);
      if(shape.size >= TOTAL_TILES) break;
    }
  }
  return shape;
}

// ===== Assign throne in ring1 =====
function chooseThrone(shape){
  const ring1 = [...shape].filter(k => {
    const {q,r} = unkey(k);
    return Math.max(Math.abs(q),Math.abs(r),Math.abs(q+r)) === 1;
  });
  return ring1[Math.floor(Math.random() * ring1.length)];
}

// ===== Build adjacency =====
function buildAdjMap(shape){
  const adj = new Map();
  for(const k of shape){
    const {q,r} = unkey(k);
    const ns = neighbors(q,r).map(([nq,nr])=>key(nq,nr)).filter(nk=>shape.has(nk));
    adj.set(k,ns);
  }
  return adj;
}

// ===== Color assignment backtracking =====
function assignColorsToShape(shapeSet, throneKey){
  const adj = buildAdjMap(shapeSet);
  const nodes = [...shapeSet];
  const colorOf = new Map();
  const counts = JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  colorOf.set(throneKey,'purple'); counts.purple--;

  const toColor = nodes.filter(n => n!==key(0,0) && n!==throneKey)
                       .sort((a,b)=>adj.get(b).length - adj.get(a).length);

  function backtrack(i){
    if(i>=toColor.length) return true;
    const node = toColor[i];
    const used = new Set(adj.get(node).map(n=>colorOf.get(n)).filter(Boolean));
    const candidates = Object.keys(counts).filter(c=>counts[c]>0 && !used.has(c));
    shuffle(candidates);
    for(const c of candidates){
      colorOf.set(node,c); counts[c]--;
      if(backtrack(i+1)) return true;
      counts[c]++; colorOf.delete(node);
    }
    return false;
  }

  return backtrack(0) ? colorOf : null;
}

// ===== Map rooms =====
function mapRooms(colorMap, throneKey){
  const pools = {};
  for(const s of rooms){
    const [name,col] = s.split('|').map(x=>x.trim());
    if(!pools[col]) pools[col]=[];
    pools[col].push(name);
  }
  for(const col in pools) shuffle(pools[col]);

  const mapping = new Map();
  mapping.set(key(0,0), {name:pools['black'].splice(pools['black'].findIndex(n=>'Black Rose Room'===n),1)[0], color:'black'});
  mapping.set(throneKey, {name:pools['purple'].splice(pools['purple'].findIndex(n=>'Throne Room'===n),1)[0], color:'purple'});

  const otherPositions = [...colorMap.keys()].filter(k=>k!==key(0,0)&&k!==throneKey);
  shuffle(otherPositions);
  for(const pos of otherPositions){
    const col = colorMap.get(pos);
    if(!pools[col] || pools[col].length===0) throw new Error(`Not enough rooms of color ${col}`);
    mapping.set(pos, {name:pools[col].pop(), color:col});
  }
  return mapping;
}

// ===== Shuffle helper =====
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

// ===== Generate lodge =====
function generateValidLodge(){
  let shape, throneKey, colorMap, roomPositionMap;
  for(let attempt=0; attempt<25; attempt++){
    shape = generateShape();
    throneKey = chooseThrone(shape);
    colorMap = assignColorsToShape(shape, throneKey);
    if(!colorMap) continue;
    try{
      roomPositionMap = mapRooms(colorMap, throneKey);
      return {shape, colorMap, roomPositionMap, throneKey};
    }catch(e){ continue; }
  }
  // fallback: retry until success
  while(true){
    shape = generateShape();
    throneKey = chooseThrone(shape);
    colorMap = assignColorsToShape(shape, throneKey);
    if(!colorMap) continue;
    try{
      roomPositionMap = mapRooms(colorMap, throneKey);
      return {shape, colorMap, roomPositionMap, throneKey};
    }catch(e){ continue; }
  }
}

// ===== Render =====
const board = document.getElementById('board');
function renderLodge(lodge){
  board.innerHTML = '';
  const {shape, roomPositionMap, throneKey} = lodge;
  const pts = [...shape].map(k=>{
    const {q,r} = unkey(k);
    const p = axialToPixel(q,r);
    return {k,q,r,x:p.x,y:p.y};
  });
  const minX = Math.min(...pts.map(p=>p.x));
  const maxX = Math.max(...pts.map(p=>p.x));
  const minY = Math.min(...pts.map(p=>p.y));
  const maxY = Math.max(...pts.map(p=>p.y));
  const groupW = (maxX-minX)+HEX_W;
  const groupH = (maxY-minY)+HEX_H;
  const offsetX = (board.clientWidth-groupW)/2 - minX;
  const offsetY = (board.clientHeight-groupH)/2 - minY;

  for(const p of pts){
    const room = roomPositionMap.get(p.k);
    const div = document.createElement('div');
    div.className = `hex ${room.color}` + (p.k===throneKey?' throne':'');
    div.style.left = `${Math.round(p.x+offsetX)}px`;
    div.style.top  = `${Math.round(p.y+offsetY)}px`;
    const lbl = document.createElement('div'); lbl.className='label'; lbl.textContent=room.name;
    div.appendChild(lbl);
    board.appendChild(div);
  }
}

// ===== Initial generation & button =====
function createAndRender(){
  const lodge = generateValidLodge();
  renderLodge(lodge);
}
document.getElementById('regen').addEventListener('click', createAndRender);
createAndRender();

</script>
</body>
</html>
