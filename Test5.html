<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lodge Generator</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #f0f0f0;
    font-family: sans-serif;
  }
  #board {
    position: relative;
    width: 800px;
    height: 700px;
    margin-top: 20px;
  }
  .hex {
    position: absolute;
    width: 80px;
    height: 70px;
    clip-path: polygon(
      50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%
    );
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 12px;
    text-align: center;
    border: 2px solid #333;
    box-sizing: border-box;
  }
  .black { background: #000; }
  .purple { background: purple; }
  .red { background: red; }
  .green { background: green; }
  .blue { background: blue; }
  .gray { background: gray; }
  .yellow { background: goldenrod; }
  .throne { border: 3px solid gold; }
  button {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 16px;
  }
</style>
</head>
<body>

<h1>Lodge Generator</h1>
<button onclick="generateLodge()">Regenerate Lodge</button>
<div id="board"></div>

<script>
const hexSize = 40; // radius
const sqrt3 = Math.sqrt(3);

// Room names per color
const rooms = {
  black: ["Black Rose Room"],
  purple: ["Throne Room 1","Throne Room 2","Throne Room 3"],
  red: ["Red Room 1","Red Room 2","Red Room 3"],
  green: ["Green Room 1","Green Room 2","Green Room 3"],
  blue: ["Blue Room 1","Blue Room 2","Blue Room 3"],
  gray: ["Gray Room 1","Gray Room 2","Gray Room 3"],
  yellow: ["Yellow Room 1","Yellow Room 2","Yellow Room 3"]
};

// Axial directions for neighbors
const directions = [
  [1,0], [1,-1], [0,-1], [-1,0], [-1,1], [0,1]
];

// Utility: shuffle array
function shuffle(arr) {
  for (let i = arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

// Generate full set of 37 hexes
function generateFullSet() {
  let tiles = [];
  for (let q=-3;q<=3;q++){
    for (let r=Math.max(-3,-q-3); r<=Math.min(3,-q+3); r++){
      tiles.push({q,r});
    }
  }
  return tiles;
}

// Helper to get neighbors
function neighbors(tile, tilesMap) {
  let n = [];
  directions.forEach(([dq,dr])=>{
    const key = `${tile.q+dq},${tile.r+dr}`;
    if (tilesMap[key]) n.push(tilesMap[key]);
  });
  return n;
}

// Check biconnectivity using DFS
function isBiconnected(tilesMap) {
  const keys = Object.keys(tilesMap);
  if (keys.length <= 2) return true;
  let visited = {};
  let parent = {};
  let low = {};
  let disc = {};
  let time = 0;
  let hasArticulation = false;

  function dfs(u, par) {
    visited[u]=true;
    disc[u]=low[u]=++time;
    let children = 0;
    neighbors(tilesMap[u], tilesMap).forEach(v=>{
      const vk = `${v.q},${v.r}`;
      if (!visited[vk]){
        children++;
        parent[vk]=u;
        dfs(vk,u);
        low[u]=Math.min(low[u],low[vk]);
        if (par!==null && low[vk]>=disc[u]) hasArticulation=true;
      } else if (vk!==par){
        low[u]=Math.min(low[u],disc[vk]);
      }
    });
    if (par===null && children>1) hasArticulation=true;
  }
  dfs(keys[0], null);
  return !hasArticulation;
}

// Reduce to 19 tiles using random removal respecting connectivity
function reduceTo19(fullTiles) {
  let attempts=0;
  while(true){
    attempts++;
    let tiles = [...fullTiles];
    let tilesMap = {};
    tiles.forEach(t=>tilesMap[`${t.q},${t.r}`]=t);
    shuffle(tiles);
    while (tiles.length>19){
      const t = tiles.pop();
      const key = `${t.q},${t.r}`;
      delete tilesMap[key];
      if (!isConnected(tilesMap) || !isBiconnected(tilesMap)) {
        tiles.push(t); tilesMap[key]=t;
        break;
      }
    }
    if (tiles.length===19) return tiles;
    if (attempts>1000) throw "Failed to generate lodge";
  }
}

// Check connectivity
function isConnected(tilesMap){
  const keys = Object.keys(tilesMap);
  if (keys.length===0) return true;
  let visited={};
  function dfs(k){
    visited[k]=true;
    neighbors(tilesMap[k], tilesMap).forEach(v=>{
      const vk = `${v.q},${v.r}`;
      if (!visited[vk]) dfs(vk);
    });
  }
  dfs(keys[0]);
  return Object.keys(visited).length===keys.length;
}

// Color assignment using backtracking
function assignColors(tiles){
  const counts = {black:1,purple:3,red:3,green:3,blue:3,gray:3,yellow:3};
  let tilesMap={}; tiles.forEach(t=>tilesMap[`${t.q},${t.r}`]=t);
  let order = tiles.slice().sort((a,b)=>neighbors(b,tilesMap).length-neighbors(a,tilesMap).length);
  let solution=null;

  function backtrack(idx){
    if (idx===order.length) {solution=true; return true;}
    const t = order[idx];
    for (let color in counts){
      if (counts[color]<=0) continue;
      const nbs = neighbors(t,tilesMap);
      if (nbs.some(n=>n.color===color)) continue;
      t.color=color; counts[color]--;
      if (backtrack(idx+1)) return true;
      t.color=null; counts[color]++;
    }
    return false;
  }
  // fix center and throne later
  order[0].color="black"; counts.black--;
  const ring1 = neighbors(order[0],tilesMap);
  const throne = ring1[Math.floor(Math.random()*ring1.length)];
  throne.color="purple"; counts.purple--;
  backtrack(0);
  return tiles;
}

// Assign room names
function assignRooms(tiles){
  let colorRooms={};
  for (let color in rooms) colorRooms[color]=rooms[color].slice();
  tiles.forEach(t=>{
    const arr = colorRooms[t.color];
    if (!arr || arr.length===0) t.room="Unknown";
    else t.room=arr.splice(Math.floor(Math.random()*arr.length),1)[0];
  });
}

// Render lodge
function renderLodge(tiles){
  const board = document.getElementById("board");
  board.innerHTML="";
  const offsetX = board.offsetWidth/2;
  const offsetY = board.offsetHeight/2;
  tiles.forEach(t=>{
    const x = offsetX + hexSize * 3/2 * t.q;
    const y = offsetY + hexSize * sqrt3 * (t.r + t.q/2);
    const div = document.createElement("div");
    div.className="hex "+t.color;
    if (t.color==="purple" && t.room.includes("Throne")) div.classList.add("throne");
    div.style.left=(x-hexSize)+"px";
    div.style.top=(y-hexSize)+"px";
    div.innerHTML=t.room;
    board.appendChild(div);
  });
}

// Generate lodge
function generateLodge(){
  const fullSet = generateFullSet();
  const tiles19 = reduceTo19(fullSet);
  const coloredTiles = assignColors(tiles19);
  assignRooms(coloredTiles);
  renderLodge(coloredTiles);
}

// Initial generation
generateLodge();
</script>
</body>
</html>
