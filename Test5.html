<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagonal Game Board</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            margin: 0;
            flex-direction: column;
            font-family: sans-serif;
            color: #eee;
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(13, 60px); /* Grid size to fit a range-3 hex */
            grid-template-rows: repeat(13, 60px);
            grid-gap: 0;
            position: relative;
            transform: translateY(20px);
        }
        .hexagon {
            width: 60px;
            height: 69px; /* Height for flat-top hex */
            position: relative;
            background: #555;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 8px;
            text-align: center;
            box-sizing: border-box;
            border: 2px solid #444;
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
            z-index: 1;
        }
        .hexagon:hover {
            transform: scale(1.1);
            z-index: 2;
        }
        .black-rose {
            background-color: #000;
            border-color: #f00;
            color: #f00;
        }
        .throne-room {
            background-color: #a0a;
            border-color: #fff;
            color: #fff;
            font-weight: bold;
        }
        .red { background-color: #a00; }
        .green { background-color: #0a0; }
        .yellow { background-color: #aa0; }
        .blue { background-color: #00a; }
        .purple { background-color: #a0a; }
        .gray { background-color: #777; }
        .button-container {
            margin-top: 30px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #555;
            color: #eee;
            border: 1px solid #777;
            border-radius: 5px;
        }
        button:hover {
            background-color: #777;
        }
    </style>
</head>
<body>

    <h1>Random Symmetric Lodge</h1>
    <div id="game-board"></div>
    <div class="button-container">
        <button id="recreate-button">Recreate Lodge</button>
    </div>

    <script>
        // Fisher-Yates shuffle algorithm
        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex != 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        // Axial coordinates to CSS Grid positions
        function toGrid(q, r) {
            const row = r + 6;
            const col = q + Math.floor(r / 2) + 6;
            return { row, col };
        }

        // Adjacency directions for axial coordinates
        const directions = [
            {q: 1, r: 0}, {q: -1, r: 0}, {q: 0, r: 1}, {q: 0, r: -1},
            {q: 1, r: -1}, {q: -1, r: 1}
        ];

        function getNeighbors(q, r, allRooms) {
            const neighbors = [];
            for (const dir of directions) {
                const neighbor = allRooms.find(room => room.q === q + dir.q && room.r === r + dir.r);
                if (neighbor) {
                    neighbors.push(neighbor);
                }
            }
            return neighbors;
        }

        function createBoard() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';

            let validConfiguration = false;
            let rooms = [];
            let attemptCount = 0;

            // Loop until a valid, symmetric, and correctly colored board is found
            while (!validConfiguration && attemptCount < 100) {
                rooms = [];
                const roomCoordinates = new Set();
                
                // 1. Place the Black Rose and its 6 adjacent rooms
                const blackRosePos = {q: 0, r: 0};
                roomCoordinates.add(JSON.stringify(blackRosePos));
                
                const ring1 = [];
                for (const dir of directions) {
                    ring1.push({q: dir.q, r: dir.r});
                    roomCoordinates.add(JSON.stringify({q: dir.q, r: dir.r}));
                }

                // 2. Find all possible symmetric pairs within a distance of 3
                const possibleSymmetricPairs = [];
                for (let q = -3; q <= 3; q++) {
                    for (let r = -3; r <= 3; r++) {
                        // Check if within distance 3
                        const s = -q - r;
                        if (Math.abs(q) + Math.abs(r) + Math.abs(s) > 6) continue;

                        const pos1 = JSON.stringify({q: q, r: r});
                        const pos2 = JSON.stringify({q: -q, r: -r});

                        // Check if positions are available and a symmetric pair
                        if (!roomCoordinates.has(pos1) && !roomCoordinates.has(pos2)) {
                            if (q !== 0 || r !== 0) {
                                if (q > 0 || (q === 0 && r > 0)) { // Add each pair only once
                                    possibleSymmetricPairs.push([{q: q, r: r}, {q: -q, r: -r}]);
                                }
                            }
                        }
                    }
                }
                
                // 3. Select 6 random symmetric pairs for the remaining 12 rooms
                shuffle(possibleSymmetricPairs);
                const selectedRooms = possibleSymmetricPairs.slice(0, 6);
                selectedRooms.forEach(pair => {
                    roomCoordinates.add(JSON.stringify(pair[0]));
                    roomCoordinates.add(JSON.stringify(pair[1]));
                });
                
                // 4. Create the final room objects
                rooms = Array.from(roomCoordinates).map(coords => {
                    const {q, r} = JSON.parse(coords);
                    return {q, r, color: null, name: null};
                });
                
                // 5. Assign colors with adjacency check
                const colorPool = [];
                const allColors = ['red', 'green', 'yellow', 'blue', 'purple', 'gray'];
                for (const color of allColors) {
                    for (let i = 0; i < 3; i++) {
                        colorPool.push(color);
                    }
                }
                shuffle(colorPool);

                const blackRoseRoom = rooms.find(r => r.q === 0 && r === 0);
                blackRoseRoom.color = 'black-rose';
                blackRoseRoom.name = 'Black Rose Room';

                const adjacentRooms = getNeighbors(0, 0, rooms);
                const throneRoom = shuffle(adjacentRooms.filter(r => r.q !== 0 || r !== 0))[0];
                throneRoom.color = 'purple';
                throneRoom.name = 'Throne Room';

                const remainingRooms = rooms.filter(r => r.color === null);
                let assignmentSuccess = true;
                for (const room of shuffle(remainingRooms)) {
                    let assigned = false;
                    for (let i = 0; i < colorPool.length; i++) {
                        const color = colorPool[i];
                        const isAdjacent = getNeighbors(room.q, room.r, rooms).some(neighbor => {
                            return (neighbor.color === color) || (neighbor.name === 'Throne Room' && color === 'purple');
                        });
                        if (!isAdjacent) {
                            room.color = color;
                            room.name = `Room - ${color}`;
                            colorPool.splice(i, 1);
                            assigned = true;
                            break;
                        }
                    }
                    if (!assigned) {
                        assignmentSuccess = false;
                        break;
                    }
                }

                if (assignmentSuccess) {
                    validConfiguration = true;
                }
                attemptCount++;
            }

            if (!validConfiguration) {
                console.error('Could not find a valid color configuration after 100 attempts.');
                return;
            }

            // 6. Render the board
            for (const room of rooms) {
                const hexagon = document.createElement('div');
                hexagon.classList.add('hexagon');
                const { row, col } = toGrid(room.q, room.r);
                hexagon.style.gridRow = row + 1;
                hexagon.style.gridColumn = col + 1;
                hexagon.textContent = room.name.includes('Room') ? room.name.replace('Room - ', '') : room.name;

                if (room.color === 'black-rose') {
                    hexagon.classList.add('black-rose');
                } else if (room.name === 'Throne Room') {
                    hexagon.classList.add('throne-room');
                } else {
                    hexagon.classList.add(room.color);
                }
                gameBoard.appendChild(hexagon);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            createBoard();
            document.getElementById('recreate-button').addEventListener('click', createBoard);
        });
    </script>

</body>
</html>
