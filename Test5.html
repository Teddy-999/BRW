<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lodge Generator</title>
<style>
  #board { position: relative; width: 800px; height: 600px; background: #eee; margin: auto; }
  .hex { position: absolute; width: 60px; height: 52px; background: #ccc; clip-path: polygon(
    25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%
  ); display: flex; align-items: center; justify-content: center; text-align: center; font-size: 10px; }
  .label { pointer-events: none; }
  .black { background: black; color: white; }
  .purple { background: purple; color: white; }
  .red { background: red; color: white; }
  .green { background: green; color: white; }
  .blue { background: blue; color: white; }
  .gray { background: gray; color: white; }
  .yellow { background: yellow; color: black; }
  .throne { border: 3px solid gold; }
</style>
</head>
<body>
<div id="board"></div>
<button id="regen">Regenerate Lodge</button>
<script>
/* ===== helper shuffle ===== */
function shuffle(a) { for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* ===== key/unkey helpers ===== */
function key(q,r){ return q+","+r; }
function unkey(k){ const [q,r]=k.split(',').map(Number); return {q,r}; }

/* ===== axial to pixel for flat-topped hexes ===== */
const HEX_W = 60, HEX_H = Math.sqrt(3)/2*HEX_W;
function axialToPixel(q,r){
  const x = HEX_W * (3/2*q);
  const y = HEX_H * (r + q/2);
  return {x,y};
}

/* ===== placeholder data functions (replace with real data) ===== */
const rooms = [
  "Black Rose Room|black", "Throne Room|purple",
  "Room1|red","Room2|red","Room3|red",
  "Room4|green","Room5|green","Room6|green",
  "Room7|blue","Room8|blue","Room9|blue",
  "Room10|gray","Room11|gray","Room12|gray",
  "Room13|yellow","Room14|yellow","Room15|yellow",
  "Room16|purple","Room17|purple","Room18|purple"
];
function buildFullSet(){ let s = new Set(); for(let q=-3;q<=3;q++){ for(let r=-3;r<=3;r++){ if(Math.abs(q+r)<=3) s.add(key(q,r)); } } return s; }
function ringKeys(r){ let arr=[]; for(let q=-r;q<=r;q++){ for(let s=-r;s<=r;s++){ let t=-q-s; if(Math.max(Math.abs(q),Math.abs(s),Math.abs(t))===r) arr.push(key(q,s)); } } return arr; }
function buildCandidatePairs(fullSet){ let arr=[]; const a=[...fullSet]; for(let i=0;i<a.length;i++){ for(let j=i+1;j<a.length;j++){ arr.push([a[i],a[j]]); } } return arr; }
/* ===== placeholder checks (implement your real versions) ===== */
function isConnected(shape){ return true; }
function minDegreeAtLeast(shape,n){ return true; }
function holeNeighborCounts(full,shape){ return {holes4:0,holes5plus:0}; }
function hasNoArticulationExceptCenter(shape){ return true; }
function buildAdjMap(shapeSet){ const map=new Map(); for(const k of shapeSet) map.set(k,[]); return map; }

/* ===== choose removal pairs by backtracking with attempt limit ===== */
function chooseRemovalPairCombination(fullSet, candidates, removePairsNeeded, maxAttempts=1000){
  const totalPairs = candidates.length;
  let result=null, attempts=0;
  shuffle(candidates);
  const selected=[];

  function buildShape(sel){ const shape=new Set(fullSet); for(const [a,b] of sel){ shape.delete(a); shape.delete(b); } return shape; }
  function quickPrune(sel){
    const shape=buildShape(sel);
    if(!isConnected(shape)) return false;
    if(!minDegreeAtLeast(shape,2)) return false;
    const {holes4, holes5plus}=holeNeighborCounts(fullSet,shape);
    if(holes5plus>0) return false;
    return true;
  }

  function backtrack(startIdx){
    if(result) return true;
    attempts++;
    if(attempts>maxAttempts) return false;

    if(selected.length===removePairsNeeded){
      const finalShape=buildShape(selected);
      if(finalShape.size!==(fullSet.size-removePairsNeeded*2)) return false;
      if(!isConnected(finalShape)) return false;
      if(!minDegreeAtLeast(finalShape,2)) return false;
      if(!hasNoArticulationExceptCenter(finalShape)) return false;
      const {holes4,holes5plus}=holeNeighborCounts(fullSet,finalShape);
      if(holes5plus>0) return false;
      result=finalShape;
      return true;
    }

    if(startIdx>=totalPairs) return false;
    const remainingNeeded=removePairsNeeded-selected.length;
    if(totalPairs-startIdx<remainingNeeded) return false;

    for(let i=startIdx;i<totalPairs;i++){
      selected.push(candidates[i]);
      if(quickPrune(selected)){
        if(backtrack(i+1)) return true;
      }
      selected.pop();
    }
    return false;
  }

  backtrack(0);
  return result;
}

/* ===== color assignment backtracking ===== */
const COLOR_COUNTS={ black:1,purple:3,red:3,green:3,blue:3,gray:3,yellow:3 };
function assignColorsToShape(shapeSet,throneKey){
  const adj=buildAdjMap(shapeSet);
  const nodes=[...shapeSet];
  const colorOf=new Map();
  const counts=JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  colorOf.set(throneKey,'purple'); counts.purple--;

  const toColor=nodes.filter(n=>n!==key(0,0)&&n!==throneKey).sort((a,b)=>adj.get(b).length-adj.get(a).length);

  function backtrack(i){
    if(i>=toColor.length) return true;
    const node=toColor[i];
    const used=new Set(adj.get(node).map(n=>colorOf.get(n)).filter(Boolean));
    const candidates=Object.keys(counts).filter(c=>counts[c]>0&&!used.has(c));
    shuffle(candidates);
    for(const c of candidates){
      colorOf.set(node,c); counts[c]--;
      if(backtrack(i+1)) return true;
      counts[c]++; colorOf.delete(node);
    }
    return false;
  }

  return backtrack(0)? colorOf : null;
}

/* ===== map rooms to positions ===== */
function mapRoomsToPositions(colorMap,throneKey){
  const pools={};
  for(const s of rooms){
    const [name,col]=s.split('|').map(x=>x.trim());
    if(!pools[col]) pools[col]=[];
    pools[col].push(name);
  }
  for(const col of Object.keys(pools)) shuffle(pools[col]);

  const mapping=new Map();
  // center
  const brIndex=pools['black'].findIndex(n=>n==='Black Rose Room');
  if(brIndex===-1) throw new Error("Black Rose Room missing");
  mapping.set(key(0,0),{name:pools['black'].splice(brIndex,1)[0],color:'black'});
  // throne
  const throneIndex=pools['purple'].findIndex(n=>n==='Throne Room');
  if(throneIndex===-1) throw new Error("Throne Room missing");
  mapping.set(throneKey,{name:pools['purple'].splice(throneIndex,1)[0],color:'purple'});

  const otherPositions=[...colorMap.keys()].filter(k=>k!==key(0,0)&&k!==throneKey);
  shuffle(otherPositions);
  for(const pos of otherPositions){
    const col=colorMap.get(pos);
    if(!pools[col]||pools[col].length===0) throw new Error(`Not enough rooms of color ${col}`);
    mapping.set(pos,{name:pools[col].pop(),color:col});
  }

  return mapping;
}

/* ===== generate lodge with retries ===== */
function generateValidLodge(){
  const fullSet=buildFullSet();
  const candidates=buildCandidatePairs(fullSet);
  const removePairsNeeded=(fullSet.size-19)/2;

  while(true){
    const shape=chooseRemovalPairCombination(fullSet,[...candidates],removePairsNeeded,25);
    if(!shape) continue;

    const ring1=ringKeys(1);
    const throneKey=ring1[Math.floor(Math.random()*ring1.length)];
    if(!shape.has(throneKey)) continue;

    const colorMap=assignColorsToShape(shape,throneKey);
    if(!colorMap) continue;

    const {holes4,holes5plus}=holeNeighborCounts(fullSet,shape);
    if(holes5plus>0) continue;
    if(holes4>0 && Math.random()>0.3) continue;

    try{
      const roomPositionMap=mapRoomsToPositions(colorMap,throneKey);
      return {shape,colorMap,roomPositionMap,throneKey};
    }catch(e){
      continue;
    }
  }
}

/* ===== render lodge ===== */
const board=document.getElementById('board');
function renderLodge(lodge){
  board.innerHTML='';
  const {shape,roomPositionMap,throneKey}=lodge;
  const pts=[...shape].map(k=>{ const {q,r}=unkey(k); const p=axialToPixel(q,r); return {k,q,r,x:p.x,y:p.y}; });
  const minX=Math.min(...pts.map(p=>p.x));
  const maxX=Math.max(...pts.map(p=>p.x));
  const minY=Math.min(...pts.map(p=>p.y));
  const maxY=Math.max(...pts.map(p=>p.y));
  const offsetX=(board.clientWidth-(maxX-minX))/2 - minX;
  const offsetY=(board.clientHeight-(maxY-minY))/2 - minY;

  for(const p of pts){
    const div=document.createElement('div');
    div.className='hex';
    const room=roomPositionMap.get(p.k);
    if(room) div.classList.add(room.color);
    if(p.k===throneKey) div.classList.add('throne');
    div.style.left=(p.x+offsetX-HEX_W/2)+'px';
    div.style.top=(p.y+offsetY-HEX_H/2)+'px';
    div.innerHTML=`<div class="label">${room?room.name:''}</div>`;
    board.appendChild(div);
  }
}

/* ===== initial render ===== */
const lodge=generateValidLodge();
renderLodge(lodge);

/* ===== regen button ===== */
document.getElementById('regen').addEventListener('click',()=>{
  const newLodge=generateValidLodge();
  renderLodge(newLodge);
});
</script>
</body>
</html>
