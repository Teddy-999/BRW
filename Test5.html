<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lodge Generator</title>
<style>
  #board { position: relative; width: 800px; height: 600px; border: 1px solid #aaa; background: #f8f8f8; }
  .hex { position: absolute; width: 60px; height: 52px; background: #ccc; clip-path: polygon(25% 0%,75% 0%,100% 50%,75% 100%,25% 100%,0% 50%); display: flex; align-items: center; justify-content: center; text-align:center; font-size:10px; box-sizing: border-box; border: 1px solid #888; }
  .hex.black { background: black; color:white; }
  .hex.purple { background: purple; color:white; }
  .hex.red { background:red; color:white; }
  .hex.green { background:green; color:white; }
  .hex.blue { background:blue; color:white; }
  .hex.gray { background:gray; color:white; }
  .hex.yellow { background:yellow; color:black; }
  .hex.throne { border: 3px solid gold; }
  .label { font-size:10px; pointer-events:none; }
</style>
</head>
<body>
<div id="board"></div>
<button id="regen">Regenerate Lodge</button>
<script>
const HEX_W = 60;
const HEX_H = 52;

// axial <-> pixel for flat-top hex
function axialToPixel(q,r){ return {x: HEX_W*(3/4*q), y: HEX_H*(r+0.5*(q&1))}; }
function key(q,r){ return `${q},${r}`; }
function unkey(k){ const [q,r]=k.split(',').map(Number); return {q,r}; }

// directions for neighbors
const directions = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];

// shuffle helper
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// get neighbors
function neighbors(q,r){ return directions.map(d=>key(q+d[0], r+d[1])); }

// distance from center
function dist(q,r){ return (Math.abs(q) + Math.abs(q+r) + Math.abs(r))/2; }

// generate lodge
function generateLodge(){
  while(true){
    const shape = new Set();
    const frontier = new Set();
    const center = key(0,0);
    shape.add(center);
    neighbors(0,0).forEach(n=>frontier.add(n));

    while(shape.size < 19){
      const options = [...frontier].filter(k=>dist(...Object.values(unkey(k)))<=3);
      if(options.length===0) break; // restart if stuck
      const pick = options[Math.floor(Math.random()*options.length)];
      shape.add(pick);
      frontier.delete(pick);
      neighbors(...Object.values(unkey(pick))).forEach(n=>{
        if(!shape.has(n)) frontier.add(n);
      });
    }
    if(shape.size===19) return shape;
  }
}

// color assignment
const COLOR_COUNTS = { black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3 };
function buildAdjMap(shape){
  const adj = new Map();
  for(const k of shape){
    adj.set(k, neighbors(...Object.values(unkey(k))).filter(n=>shape.has(n)));
  }
  return adj;
}
function assignColors(shapeSet){
  const colorOf = new Map();
  const counts = JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  const nodes = [...shapeSet].filter(k=>k!==key(0,0)).sort((a,b)=>neighbors(...Object.values(unkey(b))).length - neighbors(...Object.values(unkey(a))).length);

  function backtrack(i){
    if(i>=nodes.length) return true;
    const node=nodes[i];
    const used=new Set(neighbors(...Object.values(unkey(node))).map(n=>colorOf.get(n)).filter(Boolean));
    const candidates=Object.keys(counts).filter(c=>counts[c]>0 && !used.has(c));
    shuffle(candidates);
    for(const c of candidates){
      colorOf.set(node,c); counts[c]--;
      if(backtrack(i+1)) return true;
      counts[c]++; colorOf.delete(node);
    }
    return false;
  }
  return backtrack(0)?colorOf:null;
}

// assign rooms
const rooms = [
  'Black Rose Room|black',
  'Throne Room|purple','Purple Room 1|purple','Purple Room 2|purple',
  'Red Room 1|red','Red Room 2|red','Red Room 3|red',
  'Green Room 1|green','Green Room 2|green','Green Room 3|green',
  'Blue Room 1|blue','Blue Room 2|blue','Blue Room 3|blue',
  'Gray Room 1|gray','Gray Room 2|gray','Gray Room 3|gray',
  'Yellow Room 1|yellow','Yellow Room 2|yellow','Yellow Room 3|yellow'
];
function mapRooms(colorMap){
  const pools = {};
  for(const s of rooms){
    const [name,col] = s.split('|').map(x=>x.trim());
    if(!pools[col]) pools[col]=[];
    pools[col].push(name);
  }
  for(const col of Object.keys(pools)) shuffle(pools[col]);
  const mapping = new Map();
  // black rose
  const brIndex = pools['black'].findIndex(n=>'Black Rose Room'===n);
  mapping.set(key(0,0),{name:pools['black'].splice(brIndex,1)[0], color:'black'});

  // throne: pick randomly on first ring (distance 1)
  const ring1 = [...colorMap.keys()].filter(k=>k!==key(0,0) && dist(...Object.values(unkey(k)))===1);
  const throneKey = ring1[Math.floor(Math.random()*ring1.length)];
  const throneIndex = pools['purple'].findIndex(n=>'Throne Room'===n);
  mapping.set(throneKey,{name:pools['purple'].splice(throneIndex,1)[0], color:'purple'});

  const others = [...colorMap.keys()].filter(k=>k!==key(0,0) && k!==throneKey);
  shuffle(others);
  for(const pos of others){
    const col=colorMap.get(pos);
    mapping.set(pos,{name:pools[col].pop(), color:col});
  }
  return {mapping, throneKey};
}

// render lodge
const board = document.getElementById('board');
function renderLodge(shape,colorMap,roomMap){
  board.innerHTML='';
  const pts=[...shape].map(k=>{
    const {q,r}=unkey(k);
    const p=axialToPixel(q,r);
    return {k,q,r,x:p.x,y:p.y};
  });
  const minX=Math.min(...pts.map(p=>p.x));
  const maxX=Math.max(...pts.map(p=>p.x));
  const minY=Math.min(...pts.map(p=>p.y));
  const maxY=Math.max(...pts.map(p=>p.y));
  const groupW=(maxX-minX)+HEX_W;
  const groupH=(maxY-minY)+HEX_H;
  const offsetX=(board.clientWidth-groupW)/2 - minX;
  const offsetY=(board.clientHeight-groupH)/2 - minY;

  for(const p of pts){
    const room=roomMap.get(p.k);
    const div=document.createElement('div');
    div.className=`hex rotated ${room.color}`+(room.name==='Throne Room'?' throne':'');
    div.style.left=`${Math.round(p.x+offsetX)}px`;
    div.style.top=`${Math.round(p.y+offsetY)}px`;
    const lbl=document.createElement('div');
    lbl.className='label';
    lbl.textContent=room.name;
    div.appendChild(lbl);
    board.appendChild(div);
  }
}

// generate and render
function createAndRender(){
  const shape=generateLodge();
  const colorMap=assignColors(shape);
  const {mapping, throneKey}=mapRooms(colorMap);
  renderLodge(shape,colorMap,mapping);
}

document.getElementById('regen').addEventListener('click', createAndRender);
createAndRender();
</script>
</body>
</html>
