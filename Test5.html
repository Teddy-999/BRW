<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Symmetric Lodge</title>
  <style>
    #board { position: relative; width: 800px; height: 700px; border:1px solid #ccc; margin: auto; }
    .hex { 
      position: absolute; 
      width: 60px; height: 52px; 
      background: lightgray; 
      clip-path: polygon(
        25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%
      );
      display: flex; align-items:center; justify-content:center;
      font-size: 10px; text-align:center; 
      border: 1px solid #999;
    }
    .black { background: black; color: white; }
    .purple { background: purple; color:white; }
    .red { background:red; color:white; }
    .green { background:green; color:white; }
    .blue { background:blue; color:white; }
    .yellow { background:yellow; color:black; }
    .gray { background:gray; color:white; }
    .label { pointer-events:none; }
  </style>
</head>
<body>
  <div id="board"></div>
  <button id="regen">Regenerate Lodge</button>

<script>
// === Helper functions ===
const HEX_W = 60;
const HEX_H = 52;

// axial to pixel (flat topped)
function axialToPixel(q,r) {
  const x = HEX_W * (3/4 * q);
  const y = HEX_H * (r + q/2);
  return {x,y};
}

// generate symmetric rings
function generateRings(maxRing) {
  const pos = [{q:0,r:0}]; // center
  for(let k=1;k<=maxRing;k++){
    for(let i=0;i<6;i++){
      let dq=[1,0,-1,-1,0,1][i];
      let dr=[0,1,1,0,-1,-1][i];
      let q = 0, r = -k;
      for(let j=0;j<k;j++){
        pos.push({q,r});
        q += dq; r += dr;
      }
    }
  }
  return pos;
}

// build adjacency map
function buildAdjMap(positions){
  const keys = positions.map(p=>key(p.q,p.r));
  const map = new Map();
  const dirs = [[1,0],[0,1],[-1,1],[-1,0],[0,-1],[1,-1]];
  for(const p of positions){
    const k = key(p.q,p.r);
    const neighbors = [];
    for(const [dq,dr] of dirs){
      const nk = key(p.q+dq, p.r+dr);
      if(keys.includes(nk)) neighbors.push(nk);
    }
    map.set(k, neighbors);
  }
  return map;
}

// key helpers
function key(q,r){return `${q},${r}`;}
function unkey(k){ const [q,r]=k.split(',').map(Number); return {q,r}; }

// shuffle
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// distance from center
function distance(q,r){ return (Math.abs(q)+Math.abs(q+r)+Math.abs(r))/2; }

// === lodge generation ===
const COLOR_COUNTS = { black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3 };
const rooms = [
  'Black Rose Room|black','Throne Room|purple',
  'Red Room 1|red','Red Room 2|red','Red Room 3|red',
  'Green Room 1|green','Green Room 2|green','Green Room 3|green',
  'Blue Room 1|blue','Blue Room 2|blue','Blue Room 3|blue',
  'Gray Room 1|gray','Gray Room 2|gray','Gray Room 3|gray',
  'Yellow Room 1|yellow','Yellow Room 2|yellow','Yellow Room 3|yellow',
  'Purple Room 2|purple'
];

function generateLodge(){
  const allPositions = generateRings(3); // center + 3 rings
  // pick only 19 positions
  const center = allPositions.find(p=>p.q===0&&p.r===0);
  let lodgePositions = [center];
  
  // concentric rings
  const ring1 = allPositions.filter(p=>distance(p.q,p.r)===1);
  const ring2 = allPositions.filter(p=>distance(p.q,p.r)===2);
  const ring3 = allPositions.filter(p=>distance(p.q,p.r)===3);
  
  // pick full ring1 (6), pick 6 from ring2, 6 from ring3 -> total 19 with center
  lodgePositions = lodgePositions.concat(ring1);
  lodgePositions = lodgePositions.concat(shuffle(ring2).slice(0,6));
  lodgePositions = lodgePositions.concat(shuffle(ring3).slice(0,6));
  
  const throneCandidates = ring1.map(p=>key(p.q,p.r));
  const throneKey = throneCandidates[Math.floor(Math.random()*throneCandidates.length)];
  
  // assign colors
  const adj = buildAdjMap(lodgePositions);
  const colorOf = new Map();
  const counts = JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  colorOf.set(throneKey,'purple'); counts.purple--;
  
  const toColor = lodgePositions.map(p=>key(p.q,p.r)).filter(k=>k!==key(0,0)&&k!==throneKey);
  shuffle(toColor);
  
  for(const node of toColor){
    const used = new Set(adj.get(node).map(n=>colorOf.get(n)).filter(Boolean));
    const candidates = Object.keys(counts).filter(c=>counts[c]>0 && !used.has(c));
    const c = candidates[0] || Object.keys(counts).find(c=>counts[c]>0); // fallback
    colorOf.set(node,c);
    counts[c]--;
  }
  
  // map rooms
  const pools = {};
  for(const s of rooms){
    const [name,col]=s.split('|').map(x=>x.trim());
    if(!pools[col]) pools[col]=[];
    pools[col].push(name);
  }
  for(const col in pools) shuffle(pools[col]);
  
  const mapping = new Map();
  for(const posKey of colorOf.keys()){
    const col = colorOf.get(posKey);
    if(!pools[col] || pools[col].length===0) throw new Error('Not enough rooms of color '+col);
    mapping.set(posKey,{name:pools[col].pop(), color:col});
  }
  
  return { positions: lodgePositions, colorMap: colorOf, roomPositionMap: mapping, throneKey };
}

// === render ===
const board = document.getElementById('board');
function renderLodge(lodge){
  board.innerHTML='';
  const { positions, roomPositionMap } = lodge;
  const pts = positions.map(p=>{const xy=axialToPixel(p.q,p.r); return {p, x:xy.x, y:xy.y};});
  const minX = Math.min(...pts.map(p=>p.x));
  const maxX = Math.max(...pts.map(p=>p.x));
  const minY = Math.min(...pts.map(p=>p.y));
  const maxY = Math.max(...pts.map(p=>p.y));
  const offsetX = (board.clientWidth - (maxX-minX + HEX_W))/2 - minX;
  const offsetY = (board.clientHeight - (maxY-minY + HEX_H))/2 - minY;
  
  for(const pt of pts){
    const k = key(pt.p.q,pt.p.r);
    const room = roomPositionMap.get(k);
    const div = document.createElement('div');
    div.className='hex '+room.color + (k===lodge.throneKey ? ' throne':'');
    div.style.left=`${Math.round(pt.x+offsetX)}px`;
    div.style.top=`${Math.round(pt.y+offsetY)}px`;
    const lbl = document.createElement('div'); lbl.className='label'; lbl.textContent=room.name;
    div.appendChild(lbl);
    board.appendChild(div);
  }
}

// === initial render & regenerate ===
function createAndRender(){
  const lodge = generateLodge();
  renderLodge(lodge);
}
document.getElementById('regen').addEventListener('click', createAndRender);
createAndRender();
</script>
</body>
</html>
