<!DOCTYPE html>
<html>
<head>
  <style>
    #board { position: relative; width: 800px; height: 600px; background: #f0f0f0; }
    .hex { position: absolute; width: 80px; height: 70px; clip-path: polygon(25% 0%,75% 0%,100% 50%,75% 100%,25% 100%,0% 50%); display:flex; justify-content:center; align-items:center; border:1px solid #333; font-size:12px; text-align:center; }
    .black { background:#000; color:#fff; }
    .purple { background:purple; color:#fff; }
    .red { background:red; color:#fff; }
    .green { background:green; color:#fff; }
    .blue { background:blue; color:#fff; }
    .gray { background:gray; color:#fff; }
    .yellow { background:yellow; color:#000; }
    .throne { border:2px gold solid; }
    .label { font-size:10px; text-align:center; }
  </style>
</head>
<body>
<div id="board"></div>
<button id="regen">Regenerate</button>
<script>
const HEX_W = 80;
const HEX_H = 70;

// --- helper keys ---
function key(q,r){ return `${q},${r}`; }
function unkey(k){ const [q,r]=k.split(',').map(Number); return {q,r}; }

// --- axial to pixel for flat topped ---
function axialToPixel(q,r){ return {x: HEX_W * (3/4*q), y: HEX_H * (r + q/2)}; }

// --- build full set of 37 positions in 3 rings ---
function buildFullSet(){
  const s = new Set();
  for(let q=-3;q<=3;q++){
    for(let r=Math.max(-3,-q-3); r<=Math.min(3,-q+3); r++){
      s.add(key(q,r));
    }
  }
  return s;
}

// --- get neighbors ---
function neighbors(k){
  const {q,r} = unkey(k);
  const dirs = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  return dirs.map(([dq,dr])=>key(q+dq,r+dr));
}

// --- check connectivity ---
function isConnected(shape){
  if(shape.size===0) return true;
  const visited=new Set();
  const arr=[...shape][0];
  const stack=[arr];
  while(stack.length){
    const cur=stack.pop();
    visited.add(cur);
    for(const n of neighbors(cur)){
      if(shape.has(n)&&!visited.has(n)) stack.push(n);
    }
  }
  return visited.size===shape.size;
}

// --- degree >=2 ---
function minDegreeAtLeast(shape,minDeg){
  for(const k of shape){
    const deg=neighbors(k).filter(n=>shape.has(n)).length;
    if(deg<minDeg) return false;
  }
  return true;
}

// --- holes ---
function holeNeighborCounts(fullSet,shape){
  let holes4=0, holes5plus=0;
  for(const k of fullSet){
    if(shape.has(k)) continue;
    const nCount=neighbors(k).filter(n=>shape.has(n)).length;
    if(nCount===4) holes4++;
    if(nCount>=5) holes5plus++;
  }
  return {holes4, holes5plus};
}

// --- biconnectivity: forbid articulation except center ---
function hasNoArticulationExceptCenter(shape){
  // naive check: remove each except center
  const center=key(0,0);
  for(const k of shape){
    if(k===center) continue;
    const s=new Set(shape);
    s.delete(k);
    if(!isConnected(s)) return false;
  }
  return true;
}

// --- candidate pairs ---
function buildCandidatePairs(fullSet){
  const arr=[...fullSet].filter(k=>k!==key(0,0));
  const pairs=[];
  for(let i=0;i<arr.length;i++){
    for(let j=i+1;j<arr.length;j++){
      pairs.push([arr[i],arr[j]]);
    }
  }
  return pairs;
}

// --- shuffle ---
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

// --- choose removal pairs by backtracking ---
function chooseRemovalPairCombination(fullSet,candidates,removePairsNeeded){
  const totalPairs=candidates.length;
  let result=null;
  shuffle(candidates);
  const selected=[];
  function buildShape(sel){
    const shape=new Set(fullSet);
    for(const [a,b] of sel){ shape.delete(a); shape.delete(b);}
    return shape;
  }
  function quickPrune(sel){
    const shape=buildShape(sel);
    if(!isConnected(shape)) return false;
    if(!minDegreeAtLeast(shape,2)) return false;
    const {holes4,holes5plus}=holeNeighborCounts(fullSet,shape);
    if(holes5plus>0) return false;
    return true;
  }
  function backtrack(startIdx){
    if(result) return true;
    if(selected.length===removePairsNeeded){
      const finalShape=buildShape(selected);
      if(finalShape.size!==fullSet.size-removePairsNeeded*2) return false;
      if(!isConnected(finalShape)) return false;
      if(!minDegreeAtLeast(finalShape,2)) return false;
      if(!hasNoArticulationExceptCenter(finalShape)) return false;
      const {holes4,holes5plus}=holeNeighborCounts(fullSet,finalShape);
      if(holes5plus>0) return false;
      result=finalShape;
      return true;
    }
    if(startIdx>=totalPairs) return false;
    const remainingNeeded=removePairsNeeded-selected.length;
    if(totalPairs-startIdx<remainingNeeded) return false;
    for(let i=startIdx;i<totalPairs;i++){
      selected.push(candidates[i]);
      if(quickPrune(selected)){
        if(backtrack(i+1)) return true;
      }
      selected.pop();
    }
    return false;
  }
  backtrack(0);
  return result;
}

// --- build adjacency map ---
function buildAdjMap(shape){
  const adj=new Map();
  for(const k of shape){
    adj.set(k,neighbors(k).filter(n=>shape.has(n)));
  }
  return adj;
}

// --- assign colors ---
const COLOR_COUNTS={black:1,purple:3,red:3,green:3,blue:3,gray:3,yellow:3};
function assignColorsToShape(shapeSet,throneKey){
  const adj=buildAdjMap(shapeSet);
  const nodes=[...shapeSet];
  const colorOf=new Map();
  const counts=JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  colorOf.set(throneKey,'purple'); counts.purple--;
  const toColor=nodes.filter(n=>n!==key(0,0)&&n!==throneKey).sort((a,b)=>adj.get(b).length-adj.get(a).length);
  function backtrack(i){
    if(i>=toColor.length) return true;
    const node=toColor[i];
    const used=new Set(adj.get(node).map(n=>colorOf.get(n)).filter(Boolean));
    const candidates=Object.keys(counts).filter(c=>counts[c]>0 && !used.has(c));
    shuffle(candidates);
    for(const c of candidates){
      colorOf.set(node,c); counts[c]--;
      if(backtrack(i+1)) return true;
      counts[c]++; colorOf.delete(node);
    }
    return false;
  }
  return backtrack(0)? colorOf:null;
}

// --- map rooms ---
const rooms=[
  'Black Rose Room|black','Throne Room|purple',
  'Room1|purple','Room2|purple','Room3|purple',
  'Room4|red','Room5|red','Room6|red',
  'Room7|green','Room8|green','Room9|green',
  'Room10|blue','Room11|blue','Room12|blue',
  'Room13|gray','Room14|gray','Room15|gray',
  'Room16|yellow','Room17|yellow','Room18|yellow'
];
function mapRoomsToPositions(colorMap,throneKey){
  const pools={};
  for(const s of rooms){
    const [name,col]=s.split('|').map(x=>x.trim());
    if(!pools[col]) pools[col]=[];
    pools[col].push(name);
  }
  for(const col of Object.keys(pools)) shuffle(pools[col]);
  const mapping=new Map();
  // center
  const brIndex=pools['black'].findIndex(n=>n==='Black Rose Room');
  if(brIndex===-1) throw new Error("Black Rose Room missing");
  mapping.set(key(0,0),{name:pools['black'].splice(brIndex,1)[0],color:'black'});
  // throne
  const throneIndex=pools['purple'].findIndex(n=>n==='Throne Room');
  if(throneIndex===-1) throw new Error("Throne Room missing");
  mapping.set(throneKey,{name:pools['purple'].splice(throneIndex,1)[0],color:'purple'});
  // other positions
  const otherPositions=[...colorMap.keys()].filter(k=>k!==key(0,0)&&k!==throneKey);
  shuffle(otherPositions);
  for(const pos of otherPositions){
    const col=colorMap.get(pos);
    if(!pools[col]||pools[col].length===0) throw new Error(`Not enough rooms of color ${col}`);
    mapping.set(pos,{name:pools[col].pop(),color:col});
  }
  return mapping;
}

// --- generate valid lodge ---
function generateValidLodge(){
  const fullSet=buildFullSet();
  const candidates=buildCandidatePairs(fullSet);
  const removePairsNeeded=(fullSet.size-19)/2;
  while(true){
    const shape=chooseRemovalPairCombination(fullSet,[...candidates],removePairsNeeded);
    if(!shape) continue;
    // pick throne randomly on first ring
    const firstRing=[...shape].filter(k=>{
      const {q,r}=unkey(k);
      return Math.max(Math.abs(q),Math.abs(r),Math.abs(-q-r))===1;
    });
    shuffle(firstRing);
    const throneKey=firstRing[0];
    const colorMap=assignColorsToShape(shape,throneKey);
    if(!colorMap) continue;
    const mapping=mapRoomsToPositions(colorMap,throneKey);
    return {shape,mapping};
  }
}

// --- render ---
function renderLodge(lodge){
  const board=document.getElementById('board');
  board.innerHTML='';
  for(const [k,v] of lodge.mapping.entries()){
    const {q,r}=unkey(k);
    const {x,y}=axialToPixel(q,r);
    const div=document.createElement('div');
    div.className='hex '+v.color;
    if(v.name==='Throne Room') div.classList.add('throne');
    div.style.left=x+'px';
    div.style.top=y+'px';
    div.innerHTML=`<div class="label">${v.name}</div>`;
    board.appendChild(div);
  }
}

document.getElementById('regen').onclick=()=>{ renderLodge(generateValidLodge()); };

// initial render
renderLodge(generateValidLodge());
</script>
</body>
</html>
