<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lodge Generator</title>
<style>
  body { background: #222; color: #fff; font-family: sans-serif; }
  svg { border: 1px solid #555; margin: 20px; }
  text { font-size: 12px; dominant-baseline: middle; text-anchor: middle; fill: #fff; }
</style>
</head>
<body>

<svg id="lodge" width="1000" height="1000"></svg>

<script>
const rooms = [
  "Black Rose Room|black",
  "Throne Room|purple",
  "Purple Room 2|purple",
  "Purple Room 3|purple",
  "Red Room 1|red",
  "Red Room 2|red",
  "Red Room 3|red",
  "Green Room 1|green",
  "Green Room 2|green",
  "Green Room 3|green",
  "Blue Room 1|blue",
  "Blue Room 2|blue",
  "Blue Room 3|blue",
  "Gray Room 1|gray",
  "Gray Room 2|gray",
  "Gray Room 3|gray",
  "Yellow Room 1|yellow",
  "Yellow Room 2|yellow",
  "Yellow Room 3|yellow"
];

const size = 40 * 1.25;
const svg = document.getElementById("lodge");
const directions = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];

// Hex grid to pixel conversion (flat-topped)
function hexToPixel(q, r) {
  const x = size * 3/2 * q;
  const y = size * Math.sqrt(3) * (r + q/2);
  return [x, y];
}

// Draw a hex
function createHex(x, y, fill, name) {
  let points = [];
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 180 * (60 * i + 30 + 90);
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    points.push(`${px},${py}`);
  }
  const hex = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  hex.setAttribute("points", points.join(" "));
  hex.setAttribute("fill", fill);
  hex.setAttribute("stroke", "#000");
  hex.setAttribute("stroke-width", "2");
  svg.appendChild(hex);

  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.setAttribute("x", x);
  text.setAttribute("y", y);
  text.textContent = name;
  svg.appendChild(text);
}

// Generate axial coordinates within distance
function generateCoords(maxDist=3) {
  let coords = [];
  for (let q=-maxDist; q<=maxDist; q++) {
    for (let r=Math.max(-maxDist, -q-maxDist); r<=Math.min(maxDist, -q+maxDist); r++) {
      coords.push([q,r]);
    }
  }
  return coords;
}

// Get neighbors of a coord
function neighbors(q,r) {
  return directions.map(d=>[q+d[0], r+d[1]]);
}

// Check if room can be placed without violating same-color adjacency
function canPlace(map, coord, roomColor) {
  const [q,r] = coord;
  let same = neighbors(q,r).some(([nq,nr])=>{
    const key = `${nq},${nr}`;
    return map.has(key) && map.get(key).split("|")[1] === roomColor;
  });
  return !same;
}

// Check if every room has >=2 neighbors (except center)
function checkMinNeighbors(map) {
  for (const [key,val] of map.entries()) {
    if (val.startsWith("Black")) continue;
    const [q,r] = key.split(",").map(Number);
    const nCount = neighbors(q,r).filter(([nq,nr])=>map.has(`${nq},${nr}`)).length;
    if (nCount < 2) return false;
  }
  return true;
}

// Shuffle array
function shuffle(array) {
  for (let i=array.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [array[i], array[j]]=[array[j], array[i]];
  }
  return array;
}

// Attempt to generate a valid lodge
function generateLodge() {
  const coords = generateCoords(3);
  const center = [0,0];
  while (true) {
    let map = new Map();
    map.set("0,0", rooms[0]); // Black Rose Room

    // Throne Room adjacent to center
    const adj = shuffle(neighbors(...center));
    let thronePlaced = false;
    for (let [q,r] of adj) {
      if (coords.some(c=>c[0]===q && c[1]===r)) {
        map.set(`${q},${r}`, rooms[1]);
        thronePlaced = true;
        break;
      }
    }
    if (!thronePlaced) continue;

    // Remaining rooms
    const remRooms = rooms.slice(2);
    shuffle(remRooms);
    const emptyCoords = shuffle(coords.filter(c=>{
      const key = `${c[0]},${c[1]}`;
      return !map.has(key);
    }));

    let success = true;
    for (let room of remRooms) {
      const [name, color] = room.split("|");
      let placed = false;
      for (let i=0; i<emptyCoords.length; i++) {
        const c = emptyCoords[i];
        if (!canPlace(map, c, color)) continue;
        map.set(`${c[0]},${c[1]}`, room);
        emptyCoords.splice(i,1);
        placed = true;
        break;
      }
      if (!placed) {
        success = false;
        break;
      }
    }
    if (!success) continue;

    if (checkMinNeighbors(map)) return map;
  }
}

const lodge = generateLodge();
const centerX = 500, centerY = 500;
for (const [key,val] of lodge.entries()) {
  const [q,r] = key.split(",").map(Number);
  const [x,y] = hexToPixel(q,r);
  createHex(centerX+x, centerY+y, val.split("|")[1], val.split("|")[0]);
}
</script>

</body>
</html>
