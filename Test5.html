<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lodge Generator</title>
<style>
  #board { position: relative; width: 800px; height: 600px; border: 1px solid #aaa; margin: 20px auto; }
  .hex {
    position: absolute;
    width: 80px; height: 70px;
    clip-path: polygon(
      25% 0%, 75% 0%,
      100% 50%, 75% 100%,
      25% 100%, 0% 50%
    );
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 10px;
    text-align: center;
  }
  .black { background: black; }
  .purple { background: purple; }
  .red { background: red; }
  .green { background: green; }
  .blue { background: blue; }
  .gray { background: gray; }
  .yellow { background: yellow; }
  .throne { border: 2px solid gold; }
  .label { pointer-events: none; }
</style>
</head>
<body>
<div id="board"></div>
<button id="regen">Regenerate Lodge</button>

<script>
const HEX_W = 80, HEX_H = 70;

// ===== Helper functions =====
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function key(q,r){return `${q},${r}`;}
function unkey(k){const [q,r]=k.split(',').map(Number);return {q,r};}
function axialToPixel(q,r){const x=HEX_W*0.75*q; const y=HEX_H*(r+0.5*(q&1)); return {x,y};}

// ===== Full set / candidate generation =====
function buildFullSet(){ // example 37 hexes in hexagon
  const set = new Set();
  for(let q=-3;q<=3;q++){
    for(let r=-3;r<=3;r++){
      if(Math.abs(q+r)<=3) set.add(key(q,r));
    }
  }
  return set;
}
function buildCandidatePairs(fullSet){
  const arr=[...fullSet], pairs=[];
  for(let i=0;i<arr.length;i++){
    for(let j=i+1;j<arr.length;j++){
      pairs.push([arr[i],arr[j]]);
    }
  }
  return pairs;
}

// ===== Placeholder connectivity / degree / hole checks =====
function isConnected(shape){return true;} // implement your actual check
function minDegreeAtLeast(shape,n){return true;} // implement your actual check
function hasNoArticulationExceptCenter(shape){return true;} // implement actual check
function holeNeighborCounts(fullSet,shape){return {holes4:0,holes5plus:0};} // implement actual

// ===== Choose removal pairs =====
function chooseRemovalPairCombination(fullSet,candidates,removePairsNeeded){
  const totalPairs=candidates.length; let result=null;
  shuffle(candidates); const selected=[];
  function buildShape(sel){const s=new Set(fullSet);for(const [a,b] of sel){s.delete(a);s.delete(b);}return s;}
  function quickPrune(sel){const s=buildShape(sel); if(!isConnected(s)) return false; if(!minDegreeAtLeast(s,2)) return false; const {holes4,holes5plus}=holeNeighborCounts(fullSet,s); if(holes5plus>0) return false; return true;}
  function backtrack(startIdx){
    if(result) return true;
    if(selected.length===removePairsNeeded){
      const finalShape=buildShape(selected);
      if(finalShape.size!==(fullSet.size-removePairsNeeded*2)) return false;
      if(!isConnected(finalShape)) return false;
      if(!minDegreeAtLeast(finalShape,2)) return false;
      if(!hasNoArticulationExceptCenter(finalShape)) return false;
      const {holes4,holes5plus}=holeNeighborCounts(fullSet,finalShape);
      if(holes5plus>0) return false;
      result=finalShape;
      return true;
    }
    if(startIdx>=totalPairs) return false;
    const remainingNeeded=removePairsNeeded-selected.length;
    if(totalPairs-startIdx<remainingNeeded) return false;
    for(let i=startIdx;i<totalPairs;i++){
      selected.push(candidates[i]);
      if(quickPrune(selected)) if(backtrack(i+1)) return true;
      selected.pop();
    }
    return false;
  }
  backtrack(0);
  return result;
}

// ===== Color assignment =====
const COLOR_COUNTS={black:1,purple:3,red:3,green:3,blue:3,gray:3,yellow:3};
function buildAdjMap(shapeSet){ const map=new Map(); for(const k of shapeSet) map.set(k,[]); return map; } // implement adjacency properly
function assignColorsToShape(shapeSet,throneKey){
  const adj=buildAdjMap(shapeSet);
  const nodes=[...shapeSet];
  const colorOf=new Map();
  const counts=JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  colorOf.set(throneKey,'purple'); counts.purple--;
  const toColor=nodes.filter(n=>n!==key(0,0)&&n!==throneKey).sort((a,b)=>adj.get(b).length-adj.get(a).length);
  function backtrack(i){
    if(i>=toColor.length) return true;
    const node=toColor[i];
    const used=new Set(adj.get(node).map(n=>colorOf.get(n)).filter(Boolean));
    const candidates=Object.keys(counts).filter(c=>counts[c]>0 && !used.has(c));
    shuffle(candidates);
    for(const c of candidates){ colorOf.set(node,c); counts[c]--; if(backtrack(i+1)) return true; counts[c]++; colorOf.delete(node);}
    return false;
  }
  return backtrack(0)?colorOf:null;
}

// ===== Map rooms =====
const rooms=[
  "Black Rose Room | black",
  "Throne Room | purple",
  "Red Room 1 | red","Red Room 2 | red","Red Room 3 | red",
  "Green Room 1 | green","Green Room 2 | green","Green Room 3 | green",
  "Blue Room 1 | blue","Blue Room 2 | blue","Blue Room 3 | blue",
  "Gray Room 1 | gray","Gray Room 2 | gray","Gray Room 3 | gray",
  "Yellow Room 1 | yellow","Yellow Room 2 | yellow","Yellow Room 3 | yellow",
];
function mapRoomsToPositions(colorMap,throneKey){
  const pools={};
  for(const s of rooms){ const [name,col]=s.split('|').map(x=>x.trim()); if(!pools[col]) pools[col]=[]; pools[col].push(name); }
  for(const col in pools) shuffle(pools[col]);
  const mapping=new Map();
  const brIndex=pools['black'].findIndex(n=>n==='Black Rose Room');
  if(brIndex===-1) throw new Error("Black Rose Room missing");
  mapping.set(key(0,0),{name:pools['black'].splice(brIndex,1)[0],color:'black'});
  const throneIndex=pools['purple'].findIndex(n=>n==='Throne Room');
  if(throneIndex===-1) throw new Error("Throne Room missing");
  mapping.set(throneKey,{name:pools['purple'].splice(throneIndex,1)[0],color:'purple'});
  const otherPositions=[...colorMap.keys()].filter(k=>k!==key(0,0)&&k!==throneKey);
  shuffle(otherPositions);
  for(const pos of otherPositions){
    const col=colorMap.get(pos);
    if(!pools[col] || pools[col].length===0) throw new Error(`Not enough rooms of color ${col}`);
    mapping.set(pos,{name:pools[col].pop(),color:col});
  }
  return mapping;
}

// ===== Safe lodge generator =====
function generateValidLodge(maxAttempts=25){
  let totalAttempts=0;
  while(totalAttempts<100){
    totalAttempts++;
    for(let attempt=0; attempt<maxAttempts; attempt++){
      const fullSet=buildFullSet();
      const candidates=buildCandidatePairs(fullSet);
      const removePairsNeeded=(fullSet.size-19)/2;
      const shape=chooseRemovalPairCombination(fullSet,candidates,removePairsNeeded);
      if(!shape) continue;

      const ring1=[...shape].filter(k=>{const {q,r}=unkey(k); return Math.abs(q)<=1 && Math.abs(r)<=1 && !(q===0&&r===0);});
      if(ring1.length===0) continue;
      shuffle(ring1);
      const throneKey=ring1[0];

      const colorMap=assignColorsToShape(shape,throneKey);
      if(!colorMap) continue;

      try{
        const roomMap=mapRoomsToPositions(colorMap,throneKey);
        return {shape,colorMap,roomMap,throneKey};
      }catch(e){ continue; }
    }
    console.warn("Max attempts reached, retrying...");
  }
  throw new Error("Could not generate lodge after 100 total attempts");
}

// ===== Render lodge =====
const board=document.getElementById('board');
function renderLodge(lodge){
  board.innerHTML='';
  const {shape,roomMap,throneKey}=lodge;
  const pts=[...shape].map(k=>{const {q,r}=unkey(k);const p=axialToPixel(q,r);return {k,q,r,x:p.x,y:p.y};});
  const minX=Math.min(...pts.map(p=>p.x));
  const maxX=Math.max(...pts.map(p=>p.x));
  const minY=Math.min(...pts.map(p=>p.y));
  const maxY=Math.max(...pts.map(p=>p.y));
  const groupW=(maxX-minX)+HEX_W;
  const groupH=(maxY-minY)+HEX_H;
  const offsetX=(board.clientWidth-groupW)/2-minX;
  const offsetY=(board.clientHeight-groupH)/2-minY;

  for(const p of pts){
    const posKey=p.k;
    const room=roomMap.get(posKey);
    const div=document.createElement('div');
    div.className=`hex ${room.color}`+(posKey===throneKey?' throne':'');
    div.style.left=`${Math.round(p.x+offsetX)}px`;
    div.style.top=`${Math.round(p.y+offsetY)}px`;
    div.innerHTML=`<div class="label">${room.name}</div>`;
    board.appendChild(div);
  }
}

// ===== Init / regen =====
function initLodge(){
  const lodge=generateValidLodge();
  renderLodge(lodge);
}
document.getElementById('regen').addEventListener('click',initLodge);
initLodge();
</script>
</body>
</html>
