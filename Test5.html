<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lodge Generator</title>
<style>
  body { display:flex; flex-direction:column; align-items:center; font-family:sans-serif; }
  #board { position:relative; width:800px; height:600px; border:1px solid #ccc; margin-top:20px; }
  .hex { position:absolute; width:70px; height:60px; background-color:#eee; clip-path:polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); display:flex; align-items:center; justify-content:center; text-align:center; font-size:10px; }
  .black { background:#333; color:#fff; }
  .purple { background:purple; color:#fff; }
  .red { background:red; color:#fff; }
  .green { background:green; color:#fff; }
  .blue { background:blue; color:#fff; }
  .gray { background:gray; color:#fff; }
  .yellow { background:yellow; color:#000; }
  .throne { border:2px solid gold; }
  .label { font-size:10px; }
</style>
</head>
<body>

<button id="regen">Regenerate Lodge</button>
<div id="board"></div>

<script>
// ===== constants =====
const HEX_W = 70, HEX_H = 60;
const MAX_PAIR_ATTEMPTS = 25;
const MAX_LODGE_ATTEMPTS = 10;
const COLOR_COUNTS = { black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3 };

// ===== helper functions =====
function key(q,r){ return `${q},${r}`; }
function unkey(k){ const [q,r] = k.split(',').map(Number); return {q,r}; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function axialToPixel(q,r){ const x=HEX_W*3/4*q; const y=HEX_H*(r + 0.5*(q%2)); return {x,y}; }

// ===== build full set (hex grid 37 tiles) =====
function buildFullSet(){
  const set = new Set();
  for(let q=-3;q<=3;q++){
    for(let r=-3;r<=3;r++){
      if(Math.abs(q+r)<=3) set.add(key(q,r));
    }
  }
  return set;
}

// ===== candidate removal pairs =====
function buildCandidatePairs(fullSet){
  const arr = [...fullSet];
  const pairs = [];
  for(let i=0;i<arr.length;i++){
    for(let j=i+1;j<arr.length;j++){
      pairs.push([arr[i],arr[j]]);
    }
  }
  return pairs;
}

// ===== basic connectivity check (approx) =====
function isConnected(shape){
  if(shape.size===0) return false;
  const visited = new Set();
  const keys = [...shape];
  const stack = [keys[0]];
  while(stack.length){
    const k = stack.pop();
    if(visited.has(k)) continue;
    visited.add(k);
    const {q,r} = unkey(k);
    const neighbors = [
      [q+1,r],[q-1,r],[q,r+1],[q,r-1],[q+1,r-1],[q-1,r+1]
    ].map(([x,y])=>key(x,y)).filter(n=>shape.has(n));
    neighbors.forEach(n=>stack.push(n));
  }
  return visited.size===shape.size;
}

// ===== minimal degree check (2+) =====
function minDegreeAtLeast(shape,minDeg){
  for(const k of shape){
    const {q,r} = unkey(k);
    const neighbors = [
      [q+1,r],[q-1,r],[q,r+1],[q,r-1],[q+1,r-1],[q-1,r+1]
    ].map(([x,y])=>key(x,y)).filter(n=>shape.has(n));
    if(neighbors.length<minDeg) return false;
  }
  return true;
}

// ===== hole counts (approx) =====
function holeNeighborCounts(fullSet,shape){
  const holes4=0, holes5plus=0; // for simplicity, skip for now
  return {holes4, holes5plus};
}

// ===== choose pairs randomly with retries =====
function chooseRemovalPairCombination(fullSet,candidates,removePairsNeeded){
  for(let attempt=0;attempt<MAX_PAIR_ATTEMPTS;attempt++){
    const shuffled = shuffle([...candidates]);
    const selected = shuffled.slice(0,removePairsNeeded);
    const shape = new Set(fullSet);
    selected.forEach(([a,b])=>{ shape.delete(a); shape.delete(b); });
    if(!isConnected(shape)) continue;
    if(!minDegreeAtLeast(shape,2)) continue;
    const {holes5plus}=holeNeighborCounts(fullSet,shape);
    if(holes5plus>0) continue;
    return shape;
  }
  return null;
}

// ===== color assignment =====
function assignColorsToShape(shapeSet,throneKey){
  const nodes = [...shapeSet];
  const colorOf = new Map();
  const counts = JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0),'black'); counts.black--;
  colorOf.set(throneKey,'purple'); counts.purple--;
  const toColor = nodes.filter(n=>n!==key(0,0)&&n!==throneKey);
  shuffle(toColor);
  for(const n of toColor){
    const avail = Object.keys(counts).filter(c=>counts[c]>0);
    if(avail.length===0) return null;
    const c = avail[0]; colorOf.set(n,c); counts[c]--;
  }
  return colorOf;
}

// ===== map rooms to positions =====
const rooms = [
  "Black Rose Room|black", "Throne Room|purple",
  "Red Room 1|red","Red Room 2|red","Red Room 3|red",
  "Green Room 1|green","Green Room 2|green","Green Room 3|green",
  "Blue Room 1|blue","Blue Room 2|blue","Blue Room 3|blue",
  "Gray Room 1|gray","Gray Room 2|gray","Gray Room 3|gray",
  "Yellow Room 1|yellow","Yellow Room 2|yellow","Yellow Room 3|yellow",
  "Purple Room 1|purple"
];
function mapRoomsToPositions(colorMap,throneKey){
  const pools={};
  for(const s of rooms){
    const [name,col]=s.split('|').map(x=>x.trim());
    if(!pools[col]) pools[col]=[];
    pools[col].push(name);
  }
  for(const col of Object.keys(pools)) shuffle(pools[col]);
  const mapping = new Map();
  mapping.set(key(0,0), {name:pools['black'].pop(), color:'black'});
  mapping.set(throneKey, {name:pools['purple'].pop(), color:'purple'});
  for(const pos of colorMap.keys()){
    if(pos===key(0,0)||pos===throneKey) continue;
    const col=colorMap.get(pos);
    if(!pools[col]||pools[col].length===0) throw new Error("Not enough rooms");
    mapping.set(pos,{name:pools[col].pop(), color:col});
  }
  return mapping;
}

// ===== generate lodge =====
function generateValidLodge(){
  for(let lodgeAttempt=0;lodgeAttempt<MAX_LODGE_ATTEMPTS;lodgeAttempt++){
    const fullSet = buildFullSet();
    const candidates = buildCandidatePairs(fullSet);
    const removePairsNeeded = (fullSet.size-19)/2;
    const shape = chooseRemovalPairCombination(fullSet,candidates,removePairsNeeded);
    if(!shape) continue;
    const ring1 = [...shape].filter(k=>Math.abs(unkey(k).q)<=1 && Math.abs(unkey(k).r)<=1);
    const throneKey = ring1[Math.floor(Math.random()*ring1.length)];
    const colorMap = assignColorsToShape(shape,throneKey);
    if(!colorMap) continue;
    try{
      const roomPositionMap = mapRoomsToPositions(colorMap,throneKey);
      return {shape,colorMap,roomPositionMap,throneKey};
    }catch(e){
      continue;
    }
  }
  throw new Error("Failed to generate lodge after max attempts");
}

// ===== render =====
const board = document.getElementById('board');
function renderLodge(lodge){
  board.innerHTML='';
  const {shape,roomPositionMap,throneKey} = lodge;
  const pts = [...shape].map(k=>{
    const {q,r}=unkey(k);
    const p=axialToPixel(q,r);
    return {k,q,r,x:p.x,y:p.y};
  });
  const minX=Math.min(...pts.map(p=>p.x));
  const minY=Math.min(...pts.map(p=>p.y));
  const maxX=Math.max(...pts.map(p=>p.x));
  const maxY=Math.max(...pts.map(p=>p.y));
  const groupW=(maxX-minX)+HEX_W;
  const groupH=(maxY-minY)+HEX_H;
  const offsetX=(board.clientWidth-groupW)/2 - minX;
  const offsetY=(board.clientHeight-groupH)/2 - minY;
  for(const p of pts){
    const room=roomPositionMap.get(p.k);
    const div=document.createElement('div');
    div.className=`hex ${room.color}`+(p.k===throneKey?' throne':'');
    div.style.left=`${Math.round(p.x+offsetX)}px`;
    div.style.top=`${Math.round(p.y+offsetY)}px`;
    const lbl=document.createElement('div');
    lbl.className='label';
    lbl.textContent=room.name;
    div.appendChild(lbl);
    board.appendChild(div);
  }
}

// ===== init =====
function createAndRenderSilently(){
  try{
    const lodge=generateValidLodge();
    renderLodge(lodge);
  }catch(e){
    console.error("Failed lodge generation", e);
  }
}
document.getElementById('regen').addEventListener('click', createAndRenderSilently);
createAndRenderSilently();

</script>
</body>
</html>
