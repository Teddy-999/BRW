<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagonal Game Board</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            margin: 0;
            flex-direction: column;
            font-family: sans-serif;
            color: #eee;
        }
        #game-board {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .hex-row {
            display: flex;
            justify-content: center;
        }
        .hexagon {
            width: 80px;
            height: 92px; /* Height for flat-top hex */
            position: relative;
            background: #555;
            margin: 5px;
            margin-top: -24px; /* Correct margin for overlap */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            text-align: center;
            box-sizing: border-box;
            border: 2px solid #444;
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }
        .hexagon:hover {
            transform: scale(1.1);
        }
        .hex-row:first-child .hexagon {
            margin-top: 5px;
        }
        .black-rose {
            background-color: #000;
            border-color: #f00;
            color: #f00;
        }
        .throne-room {
            background-color: #a0a;
            border-color: #fff;
            color: #fff;
            font-weight: bold;
        }
        .red { background-color: #a00; }
        .green { background-color: #0a0; }
        .yellow { background-color: #aa0; }
        .blue { background-color: #00a; }
        .purple { background-color: #a0a; }
        .gray { background-color: #777; }
        .button-container {
            margin-top: 30px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #555;
            color: #eee;
            border: 1px solid #777;
            border-radius: 5px;
        }
        button:hover {
            background-color: #777;
        }
    </style>
</head>
<body>

    <h1>Hexagonal Game Board</h1>
    <div id="game-board"></div>
    <div class="button-container">
        <button id="recreate-button">Recreate Lodge</button>
    </div>

    <script>
        // Fisher-Yates shuffle algorithm
        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex != 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        function createBoard() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';

            const hexRowsLayout = [3, 4, 5, 6, 5, 4, 3];
            let allTiles = [];
            let tileId = 0;

            // Generate an array of tile objects with a unique ID and their position
            hexRowsLayout.forEach((numTiles, rowIndex) => {
                for (let i = 0; i < numTiles; i++) {
                    allTiles.push({ id: tileId++, row: rowIndex, col: i });
                }
            });

            // Pre-calculate adjacency for all tiles
            const getAdjacent = (tile) => {
                const adj = [];
                const directions = [
                    {r: 0, c: 1}, {r: 0, c: -1}, {r: 1, c: 0}, {r: -1, c: 0},
                    {r: 1, c: -1}, {r: -1, c: 1} // For even rows/odd rows
                ];
                // Adjust for flat-top hex grid logic
                const odd_directions = [
                    {r: 0, c: 1}, {r: 0, c: -1}, {r: 1, c: 0}, {r: -1, c: 0},
                    {r: 1, c: -1}, {r: -1, c: -1}
                ];
                const even_directions = [
                    {r: 0, c: 1}, {r: 0, c: -1}, {r: 1, c: 0}, {r: -1, c: 0},
                    {r: 1, c: 1}, {r: -1, c: 1}
                ];
                
                const neighbors = tile.row % 2 === 0 ? even_directions : odd_directions;
                
                neighbors.forEach(dir => {
                    const neighbor = allTiles.find(t => t.row === tile.row + dir.r && t.col === tile.col + dir.c);
                    if (neighbor) {
                        adj.push(neighbor.id);
                    }
                });
                return adj;
            };

            // Main loop to find a valid color configuration
            let validConfiguration = false;
            let rooms = {};

            do {
                // Reset state for a new attempt
                rooms = {};
                allTiles.forEach(t => rooms[t.id] = { id: t.id, adj: getAdjacent(t), color: null, name: null });

                // Define tile roles
                const blackRoseId = allTiles[12].id; // Center of the 37 tiles
                const nonBlackRoseTiles = allTiles.filter(t => t.id !== blackRoseId);
                const firstRingIds = rooms[blackRoseId].adj;
                const otherRooms = nonBlackRoseTiles.filter(t => !firstRingIds.includes(t.id));

                // 1. Assign Black Rose Room
                rooms[blackRoseId].color = 'black';
                rooms[blackRoseId].name = 'Black Rose Room';

                // 2. Assign Throne Room (purple) to a random adjacent spot
                const throneRoomId = shuffle([...firstRingIds])[0];
                rooms[throneRoomId].color = 'purple';
                rooms[throneRoomId].name = 'Throne Room';

                // 3. Prepare remaining rooms and colors
                const allRoomIdsToColor = otherRooms.map(t => t.id);
                const colorPool = shuffle([
                    'red', 'red', 'red', 'red', 'red', 'red',
                    'green', 'green', 'green', 'green', 'green', 'green',
                    'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow',
                    'blue', 'blue', 'blue', 'blue', 'blue', 'blue',
                    'purple', 'purple', 'purple', 'purple', 'purple',
                    'gray', 'gray', 'gray', 'gray', 'gray', 'gray'
                ]);

                // 4. Try to assign colors without adjacency issues
                let success = true;
                const shuffledRoomsToColor = shuffle(allRoomIdsToColor);
                for (let i = 0; i < shuffledRoomsToColor.length; i++) {
                    const roomId = shuffledRoomsToColor[i];
                    let assigned = false;
                    for (let j = 0; j < colorPool.length; j++) {
                        const color = colorPool[j];
                        let isAdjacent = false;
                        for (const neighborId of rooms[roomId].adj) {
                            if (rooms[neighborId].color === color) {
                                isAdjacent = true;
                                break;
                            }
                        }
                        if (!isAdjacent) {
                            rooms[roomId].color = color;
                            rooms[roomId].name = `Room - ${color}`;
                            colorPool.splice(j, 1);
                            assigned = true;
                            break;
                        }
                    }
                    if (!assigned
