<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Symmetric Lodge Generator</title>
<style>
body { display:flex; flex-direction:column; align-items:center; font-family:sans-serif; background:#f0f0f0; }
#board { position:relative; width:800px; height:700px; margin-top:20px; }
.hex { position:absolute; width:80px; height:70px;
       clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
       display:flex; align-items:center; justify-content:center; color:white;
       font-size:12px; text-align:center; border:2px solid #333; box-sizing:border-box; }
.black { background:#000; } .purple { background:purple; } .red { background:red; } .green { background:green; }
.blue { background:blue; } .gray { background:gray; } .yellow { background:goldenrod; }
.throne { border:3px solid gold; }
button { margin-top:20px; padding:10px 20px; font-size:16px; }
</style>
</head>
<body>
<h1>Symmetric Lodge Generator</h1>
<button onclick="generateLodge()">Regenerate Lodge</button>
<div id="board"></div>
<script>
const hexSize = 40, sqrt3 = Math.sqrt(3);
const directions = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];

function key(q,r){ return `${q},${r}`; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
function neighbors(tile,map){ return directions.map(([dq,dr])=>map[key(tile.q+dq,tile.r+dr)]).filter(t=>t); }

// Hex distance
function hexDistance(q,r){ return Math.max(Math.abs(q), Math.abs(r), Math.abs(-q-r)); }

// --- 1. Build symmetric lodge ---
function buildLodge(){
    let tilesMap = {};
    let tiles = [];

    // Generate all positions with distance <=3
    for(let q=-3;q<=3;q++){
        for(let r=Math.max(-3,-q-3); r<=Math.min(3,-q+3); r++){
            tilesMap[key(q,r)] = {q,r};
        }
    }

    // Center
    let center = tilesMap["0,0"];
    tiles.push(center);

    // First ring (distance=1) = always 6 tiles
    let ring1 = neighbors(center, tilesMap);
    tiles.push(...ring1);

    // Collect candidates from rings 2 & 3
    let candidates = [];
    for(let t of Object.values(tilesMap)){
        let d = hexDistance(t.q,t.r);
        if(d>=2 && d<=3) candidates.push(t);
    }

    shuffle(candidates);
    // Need 19 tiles in total: already have 7 (center+ring1)
    while(tiles.length < 19 && candidates.length){
        let t = candidates.pop();
        tiles.push(t);
    }

    // Build map for neighbor lookup
    let map = {}; tiles.forEach(t=>map[key(t.q,t.r)] = t);
    return {tiles, map, center, ring1};
}

// --- 2. Assign colors with adjacency constraints ---
function assignColors(tiles, center, ring1){
    const counts = {black:1,purple:3,red:3,green:3,blue:3,gray:3,yellow:3};
    let map = {}; tiles.forEach(t=>map[key(t.q,t.r)] = t);

    // Center black
    center.color = "black"; counts.black--;

    // Throne Room = random from first ring
    shuffle(ring1);
    let throne = ring1[0];
    throne.color="purple"; counts.purple--;

    // Order by descending degree
    let order = tiles.slice().sort((a,b)=>neighbors(b,map).length - neighbors(a,map).length);

    function bt(idx){
        if(idx===order.length) return true;
        let t = order[idx]; if(t.color) return bt(idx+1);
        for(let color in counts){
            if(counts[color]<=0) continue;
            if(neighbors(t,map).some(n=>n.color===color)) continue;
            t.color=color; counts[color]--; if(bt(idx+1)) return true; t.color=null; counts[color]++;
        }
        return false;
    }

    if(!bt(0)) throw new Error("Color assignment failed");
    return {tiles, throne};
}

// --- 3. Assign unique rooms ---
function assignRooms(tiles, center, throne){
    const fixedRooms = {black:"Black Rose Room", purple:"Throne Room"};
    let otherRooms = [];
    const colorCounts = {purple:2, red:3, green:3, blue:3, gray:3, yellow:3};
    for(let c in colorCounts){
        for(let i=1;i<=colorCounts[c];i++) otherRooms.push(`${c.charAt(0).toUpperCase()+c.slice(1)} Room ${i}`);
    }
    shuffle(otherRooms);

    tiles.forEach(t=>{
        if(t===center) t.room = fixedRooms.black;
        else if(t===throne) t.room = fixedRooms.purple;
        else t.room = otherRooms.pop();
    });
}

// --- 4. Render ---
function renderLodge(tiles){
    const board = document.getElementById("board"); board.innerHTML="";
    const offsetX = board.offsetWidth/2, offsetY = board.offsetHeight/2;
    tiles.forEach(t=>{
        const x = offsetX + hexSize*3/2*t.q;
        const y = offsetY + hexSize*sqrt3*(t.r + t.q/2);
        const div = document.createElement("div");
        div.className = "hex " + t.color;
        if(t.room.includes("Throne")) div.classList.add("throne");
        div.style.left = (x-hexSize)+"px";
        div.style.top = (y-hexSize)+"px";
        div.innerHTML = t.room;
        board.appendChild(div);
    });
}

// --- Main ---
function generateLodge(){
    try{
        let {tiles, map, center, ring1} = buildLodge();
        let {tiles:coloredTiles, throne} = assignColors(tiles, center, ring1);
        assignRooms(coloredTiles, center, throne);
        renderLodge(coloredTiles);
    }catch(e){
        console.log("Retrying lodge generation...");
        generateLodge();
    }
}

generateLodge();
</script>
</body>
</html>
