<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Black Rose Lodge — Symmetric Holes, Min-Degree ≥ 2</title>
<style>
  :root {
    /* 30% larger than 34px => ~44px */
    --hex-size: 44px; /* hex radius (corner to center), pointy-topped hexes */
  }
  body {
    background: #111;
    color: #eee;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    margin: 0;
    padding: 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }
  h1 { margin: 0; font-size: 20px; font-weight: 700; }
  .toolbar { display: flex; gap: 8px; align-items: center; }
  button {
    background: #333;
    color: #eee;
    border: 1px solid #444;
    padding: 8px 12px;
    border-radius: 10px;
    cursor: pointer;
  }
  button:hover { background: #3a3a3a; }

  .board {
    position: relative;
    width: 1000px;
    height: 800px;
    border-radius: 16px;
    background: radial-gradient(ellipse at center, #1a1a1a, #0c0c0c);
    box-shadow: inset 0 0 80px rgba(0,0,0,0.6);
    overflow: hidden;
  }

  .hex {
    position: absolute;
    width: calc(var(--hex-size) * 1.732); /* √3 * size */
    height: calc(var(--hex-size) * 2);
    clip-path: polygon(
      50% 0%,
      93% 25%,
      93% 75%,
      50% 100%,
      7% 75%,
      7% 25%
    );
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 4px;
    font-size: 12px;
    line-height: 1.1;
    color: #fff;
    box-shadow:
      0 2px 6px rgba(0,0,0,0.35),
      inset 0 0 12px rgba(255,255,255,0.05);
    user-select: none;
  }
  .hex .label {
    padding: 2px 4px;
    background: rgba(0,0,0,0.28);
    border-radius: 6px;
  }

  /* Colors */
  .black  { background: #000; }
  .purple { background: rebeccapurple; }
  .red    { background: #b11; }
  .green  { background: #197a2b; }
  .blue   { background: #1f4ea3; }
  .gray   { background: #676e78; }
  .gold   { background: #b58900; }
</style>
</head>
<body>
  <h1>Black Rose Lodge (Radius 3, Symmetric Holes, Min-Degree ≥ 2)</h1>
  <div class="toolbar">
    <button id="regen">Regenerate</button>
  </div>
  <div class="board" id="board"></div>

<script>
/* =========================
   Hex axial utilities
   ========================= */
const DIRS = [
  [ 1,  0], [ 1, -1], [ 0, -1],
  [-1,  0], [-1,  1], [ 0,  1]
];
const CENTER_KEY = '0,0';
function key(q,r){ return `${q},${r}`; }
function unkey(k){ const [q,r] = k.split(',').map(Number); return {q,r}; }
function neighbors(q,r){ return DIRS.map(([dq,dr]) => [q+dq, r+dr]); }
function axialDistance(a,b){
  const dq = a.q - b.q, dr = a.r - b.r, ds = -a.q - a.r + b.q + b.r;
  return (Math.abs(dq)+Math.abs(dr)+Math.abs(ds))/2;
}
const MAX_RADIUS = 3;
function withinRadius(q,r,rad=MAX_RADIUS){ return axialDistance({q,r},{q:0,r:0}) <= rad; }

/* Axial -> pixel (pointy topped) */
const HEX_SIZE = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'));
const HEX_W = Math.sqrt(3) * HEX_SIZE;   // width
const HEX_H = 2 * HEX_SIZE;              // height
function axialToPixel(q,r){
  const x = HEX_SIZE * Math.sqrt(3) * (q + r/2);
  const y = HEX_SIZE * 1.5 * r;
  return {x, y};
}

/* =========================
   Rooms (19 unique, exact counts)
   ========================= */
const ROOMS = [
  {name: "Black Rose Room", color: "black"}, // fixed center
  {name: "Throne Room",     color: "purple"},// fixed adjacent (random side)
  // two more purple
  {name: "Amethyst Library",   color: "purple"},
  {name: "Violet Sanctum",     color: "purple"},
  // reds
  {name: "Ruby Forge",         color: "red"},
  {name: "Crimson Hall",       color: "red"},
  {name: "Scarlet Observatory",color: "red"},
  // greens
  {name: "Emerald Garden",     color: "green"},
  {name: "Verdant Chapel",     color: "green"},
  {name: "Jade Gallery",       color: "green"},
  // blues
  {name: "Azure Pool",         color: "blue"},
  {name: "Cobalt Tower",       color: "blue"},
  {name: "Sapphire Crypt",     color: "blue"},
  // grays
  {name: "Iron Workshop",      color: "gray"},
  {name: "Steel Armory",       color: "gray"},
  {name: "Silver Vault",       color: "gray"},
  // yellows (gold)
  {name: "Golden Treasury",    color: "gold"},
  {name: "Amber Dome",         color: "gold"},
  {name: "Topaz Chamber",      color: "gold"}
];

/* =========================
   Helpers
   ========================= */
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}
function buildRadius3Set() {
  const S = new Set();
  for (let q=-MAX_RADIUS; q<=MAX_RADIUS; q++) {
    for (let r=-MAX_RADIUS; r<=MAX_RADIUS; r++) {
      if (withinRadius(q,r)) S.add(key(q,r));
    }
  }
  return S; // size 37
}
function ringKeys(dist){
  const res = [];
  for (let q=-MAX_RADIUS; q<=MAX_RADIUS; q++) {
    for (let r=-MAX_RADIUS; r<=MAX_RADIUS; r++) {
      if (withinRadius(q,r) && axialDistance({q,r},{q:0,r:0}) === dist) res.push(key(q,r));
    }
  }
  return res;
}
function mirrorKey(k){
  const {q,r} = unkey(k);
  return key(-q,-r);
}
function buildAdjacency(keysSet){
  const adj = new Map();
  for (const k of keysSet) adj.set(k, []);
  for (const k of keysSet) {
    const {q,r} = unkey(k);
    for (const [nq,nr] of neighbors(q,r)) {
      const nk = key(nq,nr);
      if (keysSet.has(nk)) adj.get(k).push(nk);
    }
  }
  return adj;
}
function isConnected(setKeys){
  if (setKeys.size === 0) return true;
  if (!setKeys.has(CENTER_KEY)) return false;
  const q = [CENTER_KEY];
  const seen = new Set([CENTER_KEY]);
  while (q.length){
    const cur = q.shift();
    for (const nk of buildAdjacency(setKeys).get(cur)) {
      if (!seen.has(nk)) { seen.add(nk); q.push(nk); }
    }
  }
  return seen.size === setKeys.size;
}
function minDegreeAtLeast(setKeys, minDeg){
  const adj = buildAdjacency(setKeys);
  for (const [k, ns] of adj) {
    if (ns.length < minDeg) return false;
  }
  return true;
}

/* =========================
   Shape with symmetric holes and min-degree≥2:
   - Start with full radius-3 set
   - Keep central ring (dist 1) fully intact
   - Pick random throne on the ring (dist 1)
   - Remove symmetric pairs from rings 2 and 3
     while preserving connectivity AND min-degree≥2
     until exactly 19 tiles remain
   ========================= */
function buildSymmetricShapeWithHoles_MinDeg2(maxRetries=200) {
  for (let attempt=0; attempt<maxRetries; attempt++) {
    const all = buildRadius3Set();           // 37 tiles
    const ring1 = new Set(ringKeys(1));      // 6 tiles

    // throne on random ring-1 tile
    const ring1Arr = shuffle(Array.from(ring1));
    const throneKey = ring1Arr[0];

    // We keep center + all ring1 intact
    let shape = new Set(all);
    const TARGET = 19;
    const toRemoveCount = shape.size - TARGET; // 18

    // Build candidate symmetric pairs from rings 2 and 3 (not ring1 or center)
    const cand = [];
    const blocked = new Set([...ring1, CENTER_KEY]);
    const seen = new Set();
    for (const k of shape) {
      if (blocked.has(k)) continue;
      const mk = mirrorKey(k);
      if (seen.has(k) || seen.has(mk)) continue;
      if (!shape.has(mk)) continue;
      const d1 = axialDistance(unkey(k), {q:0,r:0});
      const d2 = axialDistance(unkey(mk), {q:0,r:0});
      if (d1 >= 2 && d1 <= 3 && d2 >= 2 && d2 <= 3) {
        cand.push([k,mk]);
        seen.add(k); seen.add(mk);
      }
    }
    shuffle(cand);

    let removed = 0;

    // Greedy removal respecting connectivity AND min-degree≥2
    while (removed < toRemoveCount && cand.length) {
      const [a,b] = cand.pop();
      if (!shape.has(a) || !shape.has(b)) continue;

      // tentative removal
      shape.delete(a); shape.delete(b);

      if (!isConnected(shape) || !minDegreeAtLeast(shape, 2)) {
        // revert if invalid
        shape.add(a); shape.add(b);
        continue;
      }
      removed += 2;
    }

    if (shape.size === TARGET && isConnected(shape) && minDegreeAtLeast(shape, 2)) {
      return { shape, throneKey };
    }
    // else retry with a new shuffle
  }
  throw new Error("Failed to build a valid symmetric shape with min-degree ≥ 2 after several attempts.");
}

/* =========================
   Color assignment (no adjacent same color, exact counts)
   - center: black (fixed)
   - throneKey: purple (consumes 1 purple)
   - remaining colors with exact counts
   - backtracking on graph
   ========================= */
const COLOR_COUNTS = {
  black: 1,
  purple: 3,
  red: 3,
  green: 3,
  blue: 3,
  gray: 3,
  gold: 3
};

function assignColors(shapeSet, throneKey){
  const adj = buildAdjacency(shapeSet);

  // Order nodes by descending degree (harder first)
  const nodes = [...shapeSet];
  nodes.sort((a,b) => adj.get(b).length - adj.get(a).length);

  // Fixed assignments
  const colorOf = new Map();
  const counts = JSON.parse(JSON.stringify(COLOR_COUNTS)); // clone

  colorOf.set(CENTER_KEY, 'black'); counts.black -= 1;
  colorOf.set(throneKey, 'purple'); counts.purple -= 1;

  const toColor = nodes.filter(k => k !== CENTER_KEY && k !== throneKey);

  function backtrack(i){
    if (i >= toColor.length) return true;
    const node = toColor[i];
    const used = new Set(adj.get(node).map(n => colorOf.get(n)).filter(Boolean));

    const tryColors = Object.keys(counts)
      .filter(c => counts[c] > 0 && !used.has(c));
    shuffle(tryColors);

    for (const c of tryColors) {
      colorOf.set(node, c);
      counts[c]--;
      if (backtrack(i+1)) return true;
      counts[c]++;
      colorOf.delete(node);
    }
    return false;
  }

  return backtrack(0) ? colorOf : null;
}

/* =========================
   Map colors to specific rooms (unique)
   ========================= */
function mapRooms(colorMap){
  const pools = {};
  for (const r of ROOMS) {
    if (!pools[r.color]) pools[r.color] = [];
    pools[r.color].push(r);
  }
  Object.values(pools).forEach(shuffle);

  const roomByPos = new Map();
  for (const [pos, color] of colorMap.entries()){
    const room = pools[color].pop();
    roomByPos.set(pos, room);
  }
  return roomByPos;
}

/* =========================
   Render
   ========================= */
function render(boardEl, shapeSet, roomMap){
  boardEl.innerHTML = ""; // clear

  // Compute bounding box to center the group
  const pts = [...shapeSet].map(k => {
    const {q,r} = unkey(k);
    const {x,y} = axialToPixel(q,r);
    return {k, x, y};
  });
  const minX = Math.min(...pts.map(p => p.x));
  const maxX = Math.max(...pts.map(p => p.x));
  const minY = Math.min(...pts.map(p => p.y));
  const maxY = Math.max(...pts.map(p => p.y));

  const boardRect = boardEl.getBoundingClientRect();
  const groupW = (maxX - minX) + HEX_W;
  const groupH = (maxY - minY) + HEX_H;

  const offsetX = (boardRect.width - groupW)/2 - minX;
  const offsetY = (boardRect.height - groupH)/2 - minY;

  for (const {k,x,y} of pts){
    const room = roomMap.get(k);
    const div = document.createElement('div');
    div.className = `hex ${room.color}`;
    div.style.left = `${x + offsetX}px`;
    div.style.top  = `${y + offsetY}px`;

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = room.name;
    div.appendChild(label);

    boardEl.appendChild(div);
  }
}

/* =========================
   Generate one valid lodge
   ========================= */
function generateLodge(){
  // Try multiple times to find a colorable shape
  for (let tries=0; tries<50; tries++){
    const { shape, throneKey } = buildSymmetricShapeWithHoles_MinDeg2();
    const colorMap = assignColors(shape, throneKey);
    if (colorMap) {
      return { shape, colorMap };
    }
  }
  throw new Error("Could not assign colors under constraints after several attempts.");
}

function assignRoomsAndRender(){
  const board = document.getElementById('board');
  const { shape, colorMap } = generateLodge();
  const roomMap = mapRooms(colorMap);
  render(board, shape, roomMap);
}

/* UI */
document.getElementById('regen').addEventListener('click', assignRoomsAndRender);

/* Initial render */
assignRoomsAndRender();
</script>
</body>
</html>
