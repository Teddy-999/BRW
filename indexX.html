<!DOCTYPE html>
<html>

<head>
	
<meta charset="utf-8" />
<title>Black Rose Lodge — Biconnected Symmetric Generator</title>
<style>
  :root { --hex-size: 44px; } /* 30% larger than 34px -> 44px */
  body {
    background: #eee;
    color: #111;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    display: flex;
    flex-direction: column;
    align-items: left;
    padding: 20px;
    gap: 12px;
  }
  h1 { margin: 0; font-size: 20px; }
  .toolbar { display:flex; gap:8px; }
  button {
    background:#222; color:#eee; border:1px solid #444; padding:8px 12px;
    border-radius:8px; cursor:pointer;
  }
  .board {
    position: relative;
	left: 24px;
    width: 540px;
    height: 560px;
    border-radius: 12px;
    background: linear-gradient(#a49261,#bba66d);
    box-shadow: inset 0 0 60px rgba(0,0,0,0.6);
    overflow: hidden;
  }
.hex {
  position: absolute;
  width: calc(var(--hex-size) * 2);      /* swap width/height for rotation */
  height: calc(var(--hex-size) * 1.732); /* sqrt(3)*size */
  clip-path: polygon(
    0% 50%, 25% 7%, 75% 7%, 100% 50%, 75% 93%, 25% 93%
  );
  display: flex;
  align-items: center;
  justify-content: center;

  box-sizing: border-box;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4), inset 0 0 8px rgba(255,255,255,0.03);
  user-select: none;
  text-align: center;
  color: #fff;
  font-size: 12px;
  line-height: 1.1;
  padding: 6px;
}
  .hex:hover { transform: translateY(-4px); }
  .label {
    background: rgba(0,0,0,0.28); border-radius:6px; padding:2px 6px;
  }
  .black  { background:#000; }
  .purple { background: rebeccapurple; }
  .red    { background: #b11; }
  .green  { background: #197a2b; }
  .blue   { background: #1f4ea3; }
  .gray   { background: #676e78; }
  .yellow { background: #d6b500; }

  /* highlight throne */
  .throne {
    box-shadow: 0 0 0 4px rgba(255,255,255,0.06), 0 6px 18px rgba(0,0,0,0.6);
    border: 2px solid rgba(255,255,255,0.06);
  }
   /* highlight empty */
  .empty { 
    background: #333333; 
  }
	
  .note { font-size:13px; color:#bbb; }

  .error {
    border: 1px solid #e63946;
    background: #ffe8ea;
    color: #8b0000;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    margin: 1rem 0;
  }
  .hidden { display: none; }
  .error ul { margin: 0.25rem 0 0; padding-left: 1.2rem; }
  .error strong { display: block; margin-bottom: 0.25rem; }

</style>
</head>
	
    <script>
		var rooms = [ 
  		"Black Rose#1|black",
  		"Throne Room#2|purple",
  		"Amethyst Library|purple",
  		"Violet Sanctum|purple",
  		"Ruby Forge|red",
  		"Crimson Hall|red",
  		"Scarlet Observatory|red",
  		"Emerald Garden|green",
  		"Verdant Chapel|green",
  		"Jade Gallery|green",
  		"Azure Pool|blue",
  		"Cobalt Tower|blue",
  		"Sapphire Crypt|blue",
  		"Iron Workshop|gray",
  		"Steel Armory|gray",
  		"Silver Vault|gray",
  		"Golden Treasury|yellow",
  		"Amber Dome|yellow",
  		"Topaz Chamber|yellow"
		];
		
	var rules=[ 
"1. [b]Umbras[/b]. They are of arche type nightmare (see evocation card). They are assigned to a mage (max. 1 per evocation slot) and not summoned. Once assigned, they are owned by the Black Rose. Effects allow to take temporary control over them. They are still evocations. They become activated first in the evocation phase. Upon defeat (step 2) of a mage, assigned evocations get removed. Summoned evocations remain in play though.",

"2. [b]Alchemy, elements and *[/b]. The enhancement effect on a spell can only be resolved, if [b]previously revealed[/b] spells on the mage‘s board show the appropriate symbols. The spell that is being resolved cannot contribute to these symbols. Also the element * counts as all elements all the time. It is NOT like in BRW that once you use it you have to turn it into a specific element. An effect requiring a specific element can always target *. This is why a mage with a personal spell providing the * element combines so well with Alchemy.",

"3. [b]Avatar[/b]. When playing with an Avatar, you must use the Avatar event deck, not the standard event deck. During cleanup phase, you put one cube on one jinx on an Avatar and you remove one evocation assigned to the Avatar. An Avatar is immune to Black Rose damage and so are its evocations. You can assign an Umbra on an Avatar, but it will not inflict damage. If an Avatar‘s command card asks you to move the Avatar without priority, it is the crown holders choice.",

"4. [b]Remove[/b]. Remove-effects from school spells do only work on non-forgotten (see arche type on evocation card) evocations with a [b]health value of 3[/b] or less, as printed onthe evocation card. Damage on the evocation does not change the health value. With certain upgrades you can raise the health value. When removing evocations [b]owned[/b] by you, this limitation does NOT apply. If a forgotten spell has the remove clause, it may be applied to [b]all[/b] evocations independent from their health value (unless stated otherwise in the effect).",

"5. [b]Evocations[/b]. Evocation damage is [b]not[/b] considered to be mage damage. It will not trigger traps which require damage inflicted by a mage.",

"6. [b]Quests[/b]. When you draw and keep a new quest card it becomes an ACTIVE quest. All ACTIVE quest cards are placed face down on the left hand side of the mage board next to the active quest symbol. Beneath the title of the quest you find a task to be fulfilled, advancing the quest. If there are cube slots available, that many repetitions are required (tracked by placing cubes in those slots), otherwise fulfilling the task one time is sufficient to COMPLETE the quest. When you fulfill the task the first time, the quest card is revealed. When COMPLETED, return any cubes on the quest card to your reserve, place the quest card to the right of the mage board next to the completed/solved quest symbols and now it is considered COMPLETED. Every COMPLETED spell can become SOLVED if you choose to do so DURING ONE OF [b]YOUR[/b] MAGE ACTIVATIONS (before or after you take an action, not during an action). In that case, you resolve the quest effect on the lower part of the COMPLETED quest card and take the power points on the lower right corner of the quest card. Then you flip the quest card face down. Now the quest and the quest card are considered to be SOLVED. Some [b]game effects can also solve ACTIVE or COMPLETED quests[/b]. In that case only receive the power points, but do not resolve the quest effect. The [b]quest limit[/b] on your mage card applies to ACTIVE and COMPLETED quests separately, but [b]only[/b] when checked during the Black Rose phase. ",

"7. [b]Quests and the Black Rose[/b]. The Black Rose only gains power points for quests which are discarded by players choice (optional, step 4) in the Black Rose phase, [b]not[/b] for discarding due to exceeding the quest limit (step 6). The Black Rose also gains power points, if an effect lets it draw a quest. Quest from moon 1: 1pp, from moon 2: 2pp, from moon 3: 3pp. Only the quests which grant power points to the Black Rose go to the Event Board Quest Slot.",

"8. [b]Immunity[/b]. A mage and their evocations are immune to damage [b]inflicted[/b] oder [b]converted[/b] by them. The Avatar and its evocations are also immune to Black Rose damage.",

"9. [b]Target Mage or Model[/b]. If one of your spells/effects has the [b]mage or model icon[/b] as target, this EXCLUDES your mage (self).",

"10. [b]Avatar and evocation activation[/b]. The Avatar is considered to be a mage. Therefore, the evocations it owns are activated in play order among the mages in the evocation phase. The activation of the Black Rose‘s evocations at the beginning of this phase only refers to evocations owned by the Black Rose, like of arche type Nightmare (Umbras).",

"11. [b]Activation (mage)[/b]. During the action phase, each mage gets [b]at least 2 activations[/b] and usually 4 to 6 actions. In every activation, you [b]must[/b] take either 1 or 2 actions. Only if there is no action available, you can and must pass. After players have done their first activation in turn order, they will take their second and so on until all mages have passed.",

"12. [b]Ranking for points[/b]. If you are part of a ranking for defeat, rebuilding rooms or game and ranking of trophies or quests, because you have [b]at least 1[/b] according item (cube, trophy, quests) in the ranking, you will ALWAYS get 1 power point. A tie subtracts 1pp, but the result can NEVER be lower than 1.",

"13. [b]Discarding a forgotten spell[/b]. When you would discard a forgotten spell from your hand or mage board to your memories, it is taken out of the game. It can never be part of your memories. The only 3 valid places for forgotten spells are player's hand, mage board and forgotten deck. Forgotten cards going to somewhere else are removed from the game.",

"14. [b]First player[/b]. The crown holder becomes the first player at the beginning of EVERY phase. This can happen at the beginning of the study phase, the action phase and the evocation phase.",

"15. [b]Large evocation[/b]. You cannot own more than 1 evocation with a large base.",

"16. [b]Momentum[/b]. To use the momentum action (move up to 1), you must discard any [b]ready[/b] card of your choice from your mage board (you are free to chose Quick, I, II or III as long as it is ready; it is Independent from the casting order). Active spells (activated trap or protection spells, meaning unrevealed with a marker on it) cannot be used, since they are not ready anymore. ",

"17. [b]Upgrade limit[/b]. An evocation can only have 1 upgrade.",

"18. [b]Equipment limit[/b]. You cannot own two equipments with the same name.",

"19. [b]Druidic and Death schools[/b]. Both have been reworked by LMS. Get the new school cards from the LMS Web App Print & Play section: https://app.ludusmagnusstudio.com/pages/_BRWR/brwrPrinteplay.php#!",

"20. [b]Black Rose room[/b]. To pay the cost for the Black Rose room, you must discard cards [b]from your hand[/b] not the mage board.",

"21. [b]Spell targeting[/b]. A target for a spell is selected once the spell is [b]revealed[/b] and the center instability symbol (if any) has been applied to the room of the casting mage. It’s type must match the target icon on the spell and if there is also a number given with this target icon, the target must be [b]within [/b]this range and in [b]line of sight[/b]. The asterisk stands for everywhere in the Lodge, so no range and line of sight is applied. You cannot target mages in their cells. The 5-point star means special, so you find instructions in the spell‘s effect. Once a [b]valid target[/b] has been selected for the spell, it will remain the same for the spell‘s effect resolution. Even if the target is [b]moved[/b] out of range or line of sight gets lost, you still continue to resolve the effect against the chosen target, [b]unless[/b] the target is a mage and gets put into their cell during the effect resolution.<p> A word about LOS in the Rebirth rules. The Rebirth rules are not exact in this regard. In the old BRW rules there is a better wording and an example. LOS works in a straight line away from the caster. This line runs through the center of every intermediate room. Or in other words, LOS runs through the middle of the doors. Or LOS is like a star with you in the middle.",

"22. [b]Defeat interrupting an effect[/b]. Before interrupting an effect to resolve a defeat, execute the effect up to the end of the current sentence (next '.'). In general after the defeat you continue resolving [b]the interrupted effect[/b] with its next sentence of the SAME effect, but [b]consecutive effects of the interrupted action are stopped[/b]. Heh? What does that mean? A spell has only ONE effect (or one reverse effect). See page 15c core rules. If this effect is interrupted by a defeat, it continues resolution with the next sentence of the [b]same[/b] effect. See page 16 core rules how card effects are a series of sentences. The same is true for a rooms effect. Note that if after defeat interruption the continued effect provides a move, this move can get you out of your cell (not clear from the contradicting rules). A physical action is different, because it has a [b]series[/b] of effects (page 16) like 'Move 1.' then 'Move 1.' then 'Punch.'. Thus, after the defeat the consecutive effects are [b]not[/b] executed.",

"23. [b]Room activation[/b]. The rules are a bit vague about what exactly room activation is and how the timing works. If an effect allows you to activate a room (in most cases a physical action), then you first check if the room is available (not showing the red crossed effect or the effect allows activating a used/not available/flipped room). In that case you you ACTIVATE the room. Then triggered effects like ‚when X activates room Y’ happen. Then pay the cost (if the room effect has any) and if you do, you can resolve the effect of the room. Finally, if the room has a room token on the available side, flip that token to the red-crossed used side. This means that you can activate a room, even if you cannot pay for or resolve its effect.",

"24. [b]Pay cost for an effect[/b]. You can only resolve an effect if you can pay its full cost. Cost can be for example 'lose 1pp' or 'discard x cards'. In most cases the effect says 'if you do, get this effect' but this is not used consistently. Sometimes or in the old BRW it would just say 'to do this effect'. Just act as if the clause 'if you do, get this effect' would be always there when a cost is involved. If cost is only part of one side of a players choice (or) and you cannot or do not pay the cost, you cannot choose that side of the or choice. In short, if you cannot pay the cost, you cannot reap the benefit tied to it.",

"25. [b]Resolving partial Effects[/b]. You must resolve [b]as much[/b] of an effect as you can. Even if a part of an effect cannot be resolved (for example no valid target, see also ‚ 'dummy target' in the rules/FAQ), you continue resolving the effect with its next part or sentence. If an effect or a part of an effect has a condition, like for example a cost to pay or in Alchemy school an element combination needed to use the enhanced effect, then you skip the whole part of the effect under the 'condition umbrella', if you cannot fulfill the condition.",

"26. [b]Or choice[/b]. No cheating here. If you cannot do or pay the cost for one side of an 'or' choice, you cannot pick that side.",

"27. [b]Preparing spells[/b]. It is an easy rule but sometimes missed by beginners. When you place spells face down on your mage board, you must remember that later on you will flip them over once you reveal the spell to resolve it. The effect you want to happen is the one on the bottom, once the card is prepared face down. When revealing a spell, you do [b]not have a choice[/b] of which side to resolve. Also note that prepared cards are considered to be 'ready'. Only ready cards can be cast. In case of trap or protection spells, casting them means putting a respective token on it to show that they are now active and may be triggered. They are [b]not[/b] ready anymore and cannot be used for momentum.",

"28. [b]Card drawing in the study phase[/b]. Especially for beginners there can be some chaos when drawing cards. Make sure that for drawing and selecting cards you [b]use an area of the table which cannot be confused with your memories or grimoire[/b]. If table space is restricted, people tend to lay down cards in front of them (where usually the mage board is), only to pick up the wrong stack of cards later on. First place your hand cards face down in this separate area. Then draw and add the 2 cards from your grimoire to those hand cards. Now draw the 4 cards from the library and put them in the same separate area, but [b]do not mix them up with your hand cards[/b]! Most likely you will now move forth and back several times between those two stacks (hand cards and 4 library drawn cards) to select 2 of the 4 library drawn cards. Many beginners just draw all those cards to their hand and discard two from their hand afterwards. This is against the rules! You must discard 2 cards from the 4 library cards. For beginners it might be easier, if you just lay down your hand cards and the 4 library cards to the left of them [b]face up[/b]. Don’t worry too much. Only the most veteran players will have time and brain capacity to look across the table to identify your cards. Also make sure that the 2 discarded library cards go to the libraries discard and [b]not[/b] your memories or grimoire. ;)  Remember, it’s just a game. As a [b]house rule for beginners[/b], you may forgo the 2 out of 4 choice and simply draw 2 cards from the library to the hand. You can see how this will reduce a beginning players confusion A LOT. Finally, at the end of the study phase, discard your hand cards down to the hand size limit (the one on your mage card).",

"29. [b]Hand size limit[/b]. Hand size is only [b]checked at the end of the study phase[/b] and you eventually have to [b]discard to the memories[/b] to obey the limit. You can have any number of cards in your hand at any other moment of the game. This is similar to active or completed quests, which are only checked during the Black Rose phase against the quest limit. Also note that [b]discarding is always done to your memories[/b] unless an effect says otherwise. Like [b]drawing is done from your grimoire[/b], unless instructed differently.",

"30. [b]Optional card discarding in the study phase[/b]. Have you ever done this? I did not. During the study phase, you are allowed to choose and discard 1 hand card to the [b]discard of the library[/b] (each school has its own discard pile). Usually the game does not recycle the cards in the memories a lot. This mechanism is used in deck builder games to thin your deck from weak cards. However, BRW is not a deck builder in this traditional sense. In some games players will not even shuffle there memories once to build a new grimoire.",

"31. [b](In)stability spells or now called unstable spells[/b]. If a spell is revealed in order to be resolved, the [b]FIRST[/b] thing you [b]MUST[/b] do is check for 'spell is revealed' triggers and then [b]immediately[/b] apply the (in)stability icon in the middle of the card (if there is any, put one of your cubes in the leftmost empty slot of your room). I cannot count how often this is forgotten or applied 5 actions later 'oh I forgot to do it 10 minutes ago…'. Only then you check for possible other triggers, choose and announce a target, check again for triggers, resolve the spells effect.",

"32. [b]Forgotten spell deck is no school deck[/b]. Really! The only means to draw cards from the forgotten deck is if you are specifically instructed to do so, for example by the Black Rose room. The simple 'draw a spell from the library/school' can [b]never[/b] draw cards from the forgotten spell deck. A few schools or custom spells allow you to draw a forgotten spell, but they state this explicitly.",

"33. [b]Empty decks[/b]. Want to draw a card and the deck is empty? Just shuffle the respective discard pile to form a new deck to draw from.",

"34. [b]Draw and reveal an event[/b]. When done for any reason, card shows the crown symbol, the player who drew the card gets the crown token (but does not yet become start player, only at the beginning of the next phase). ",

"35. [b]Discarding an event due to an effect[/b]. When an effect requires an event card to be discarded, that card must be chosen from those revealed on the event board and placed in the event discard pile. The Black Rose does [b]not[/b] gain the power points for this.",

"36. [b]Do not want to cast a spell?[/b]. According to the rules, you must take all possible actions before you can pass for the game turn. But you can always discard a ready spell for momentum, allowing you to move 0 or 1 instead of casting the spell.",

"37. [b]Defeat itself can be interrupted[/b]. When a mage is defeated, resolution of the current effect is interrupted at the next '.'. There are protection spells which prevent defeat or which heal, leading to preventing the defeat. In case you wonder about the timing: This is checked as first step during a defeat and if applicable, can end defeat resolution right away, leaving the mage eventually undefeated.",

"38. [b]Healing and Converting[/b]. Two basic concepts which are not exactly explained in the rules. Healing basically means that the target may remove the given number of damage cubes. Players have the free choice to which cubes they remove. Avatars remove damage from the right to the left. Converting means to exchange cubes (damage/(in)stability) on a target with cubes from the converting party (mages, Avatar, Black Rose). Again, players are free which cubes to convert and Avatars convert non-black cubes from the right to the left. Remember the immunity rule. A mage cannot convert damage on itself or its evocations. ",

"39. [b]Revenge from the cell[/b]. While you are hanging out in your cell, waiting to punch someone in the face, there are still some tools available to you. You can trigger an active trap while in your cell. Persisting spells still do their effect and you can activate your evocations during the evocation phase while in your cell. [b]Pro tip[/b]: you will very likely land in your cell several times, more so the more players are present. Plan to rebuild one of the rooms next to your cell with PRIORITY right from the start. Also plan a secondary room in reach of a single physical action from your cell. These are easy and very effective points, since you will not waste extra physical actions just to get there. If you have a green room next to your cell, lucky you. The job just got easier. If it is the green room which grants 2 power points once rebuild, then double lucky you.",

"40. [b]Jinx cards[/b]. Yes, they stay in place even when defeated.",

"41. [b]Default drawing and discarding of spells[/b]. It may be redundant, but it is asked often by beginners. By DEFAULT spell cards are drawn from your grimoire and discarded to your memories, UNLESS stated otherwise.",

"42. [b]Dummy target[/b]. This is a confusing one. The purpose for this rule is to provide a way to resolve spells even if there is no model available as a target. This is in line with the overall purpose of BRW to resolve as much as possible from a spell or effect. However, technically you can select a dummy target for your spell even if a real target could be chosen instead. There are some rare cases which could lead to  ‚creative optimization to exploit dummy targets instead of real targets’ and which somewhat goes against the spirit of the game. It is up to you if you want to allow those exploits to be used. Remember that the dummy target does NOT apply to physical actions. Punching the air is not an option. ",

"43. [b]Game end[/b]. Surprising enough, the question regularly occurs. The game ends [b]at the end of the clean-up phase[/b] IF a player or the Black Rose have reached or surpassed the End Game trigger / Black Rose Moon Cube on the Power Board which is by default 30.",

"44. [b]Range[/b]. If an effect shows the room icon (hexagon) with a number in it like Room(N), then this number N defines the range of this effect. Important is that this includes any rooms [b]UP TO[/b] that range. This works exactly the same like for choosing a target for a spell. This is regularly challenged by players, like for example on an Avatar command card: 'Prio 1: Move to Room(2)' does not necessarily mean that you have to move at all. Room(2) includes Room(1) and Room(0) as well as possible options, depending on the Prio 1 given on the Avatar card. Another example is 'inflict 1 damage in each Room(1) from the target'. This includes all rooms at distance 1 but also the room at distance 0 from the target, unless there is a clause on the card excluding a specific room. The same rule applies to Model(N). (N) always defines a range and [b]not[/b] a distance as is defined in the base rules about targeting, unless specified otherwise in the effect. [b]Therefore please note:[/b] 'each adjacent room' is [b]NOT[/b] equal to 'each Room(1)' but instead is equal to 'each Room(1) except Room(0)'.",

"45. [b]Gaea[/b]. There are some misprints and misunderstandings about how the tool/root thing works. If the Avatar Gaea triggers her circle symbol, she places a root in her room if there is no root already there. Then for ALL rooms which have a root in it (and the root still has an empty slot for a cube), you must move the rightmost instability from the regular instability slots onto the leftmost free slot of the root in that room. It is like the roots are soaking up instability from the rooms they are in. Yes, that means if the players do not care about handling the roots, Gaea can win pretty fast. Gaea overall works against instability strategies by soaking up the instability with her roots and she heals quite a bit, working against slow damage inflicting strategies and then she steals power points here and there. Overall this feels a bit like slowing down players progress, unless you utilize other strategies. Attention if you add schools which slow down the game as well like Hex for example. It may start to feel a bit 'slow'.",

"46. [b]Entering a room[/b]. When moving, you do this in a sequence of 'Move 1.' effects. A model with a speed of 2 may 'Move 1.' and may do another 'Move 1.'. It will enter all rooms on its way except for its starting room. If a model is placed in a room, it will only enter that room but not the rooms between its starting and its end position."
		];

		var allscenarios=[
			"*XXX General|Cologne, Germany - You never know|None.|Standard.|None.|*",
			"BRW-R-ROTAS Rebirth ROTAS|Tijuana, Mexico - Brujeria Especial|None.|<ul>Rooms: (53,98). Schools: (3,8,30).</ul>|None.|None.",
			"BRW-SATOR BRW SATOR|Plymouth, England - The Shattered Rose|<ul><li>13 Black Rose Power Cards.</li></ul>|<ul><li>Follow the standard setup as indicated in the core box manual. Use the indicated map to create the Lodge.</li>Rooms: (62,125). Schools: (29,32,35).<li><b>Draft the Black Rose Power Cards:</b> Each player draws 2 Power Cards from the deck and chooses one and passes the other to the player on his left. Before starting the game each player must reveal a Power Card. The second Power Card will be revealed once you reach the second Moon.</ul>|<ul><li><b>Black Rose Power Cards:</b> Each player can use the revealed Power Cards in their possession following the rules shown on them.<li><b>Second Moon:</b> Each player reveals their second Power Card.</ul>|*",
		];

		var allhonmen=[		
			"* General|2 pp - Forbidden Madness: At the end of the game, you have a Forgotten Spell in your hand.|",
			"* General|3 pp - Deep Mysteries: You did cast 2 or more Forgotten Spells during the game.|",
			"* General|4 pp - Multi Talent: You did cast at least 1 spell from each School in the Library.|",
			"* General|3 pp - Battle Hardened: At the end of the game, if you have given away more Trophies than any other Mage.|",
			"* General|4 pp - Invincible: At the end of the game, no opposing Mage has one of your Trophies.|",
			"* General|3 pp - Here I stand: At the end of the game, your Mage is the only Mage in the Black Rose Room.|",
			"* General|1 pp - Master of the Rose: At the end of the game, your Mage is in the Black Rose Room.|",
			"* General|2 pp - Forbidden Knowledge: You used a Forgotten Spell during the game.|",			
			"* General|2 pp - Royal Blood: At the end of the game, you hold the Crown.|",
			"* General|X pp - Reckless: At the end of the game, you have at least one Trophy from each enemy Mage. Gain 1 pp for every enemy Mage.|",
			"* General|3 pp - Professor: At the end of the game, you have at least 5 Spells in your hand.|",
			"* General|X pp - Influencer (red): During the game, 1 pp for every red room which you rank 1st on rebuilding/destruction.|",
			"* General|X pp - Influencer (green): During the game, 1 pp for every green room which you rank 1st on rebuilding/destruction.|",
			"* General|X pp - Influencer (yellow): During the game, 1 pp for every yellow room which you rank 1st on rebuilding/destruction.|",
			"* General|X pp - Influencer (blue): During the game, 1 pp for every blue room which you rank 1st on rebuilding/destruction.|",
			"* General|X pp - Influencer (purple): During the game, 1 pp for every purple room which you rank 1st on rebuilding/destruction.|",
			"* General|X pp - Influencer (gray): During the game, 1 pp for every gray room which you rank 1st on rebuilding/destruction.|",
			"BRW-R-CORE Rebirth Core|2 pp - Architect of Tomorrow: At the end of the game, you have ranked 1st or 2nd on rebuilding at least 4 Rooms.|",
			"BRW-CORE BRW Core|2 pp - Architect of Ruin: At the end of the game, you have ranked 1st or 2nd on destroying at least 4 Rooms.|",
			"* General|3 pp - Shadow Walker: At the end of the game, you have an Evocation in each purple Room.|",
			"* General|3 pp - Master Summoner: At the end of the game, you control 3 Evocations.|",
			"* General|2 pp - Duelist: During the game, you defeat a Mage alone.|",
			"* General|2 pp - Opportunist: At the end of the game, you have solved at least 3 Quests.|",
			"* General|2 pp - Hunter: During the game, you triggered at least 3 Traps.|",
			"* General|3 pp - Tank: During the game, you triggered at least 3 Protection spells.|",
			"* General|4 pp - Collector: At the end of the game, you hold cards of at least 5 different Schools in your hand.|",
			"* General|3 pp - Nemesis: At the end of the game, if you have 3 or more Trophies from a single Mage.|",
			"* General|2 pp - Elementalist: During the game, whenever you reveal the 4th spell with the same Element on your Mage Sheet.|",
		];

		
		
        var allschools=[
           		"1|BRW-R-CORE Rebirth Core: <b>Alchemy</b> Setup: Nigredo <b>Mages:</b> Angela, Bella",
				"2|BRW-R-CORE Rebirth Core: <b>Agony</b> Setup: Succubus <b>Mages:</b> Rikkart, Bella, Prospero",
				"3|BRW-R-CORE Rebirth Core: <b>Hex</b> Setup: Jinxes <b>Mages:</b> Gramigna, Alisha, Maelice, Saba",
				"4|BRW-R-CORE Rebirth Core: <b>Nightmare</b> Setup: Umbra <b>Mages:</b> Baron Doria",
				"5|BRW-R-CORE Rebirth Core: <b>Shamanic</b> Setup: Totem <b>Mages:</b> Sefu, Dai Jin",
           		"6|BRW-R-CORE Rebirth Core: <b>Technomancy</b> Setup: Cadaver, Colossus, Upgrades <b>Mages:</b> Arianna, Pyotr, Dai Jin",
				"7|BRW-R-ROTAS Rebirth ROTAS Madness: <b>Chaos</b> Setup:  Vastum Tokens, Chaos Effect cards <b>Mages:</b> Landolfo II",
				"8|BRW-R-ROTAS Rebirth ROTAS North Winds: <b>Druid</b> Setup: Bjorn/Ursa, Loki/Krokodilus <b>Mages:</b> Kormac, Dai Jin",
				"9|BRW-R-ROTAS Rebirth ROTAS Last Dynasty: <b>Heka</b> Setup: Jinxes, Pharaoh; OPTIONAL: Rebirth ROTAS Sanctuary of Anubis Room to summon Pharoah more easily <b>Mages:</b> Imhotep, Saba, Graminga, Maelice",
				"10|BRW-R-ROTAS Rebirth ROTAS Antiquities: <b>Oracle</b> Setup: Aruspice <b>Mages:</b> Cassandra, Dai Jin",
				"11|BRW-R-APO Rebirth Apocalypse: <b>Death</b> Setup: Destiny Tokens <b>Mages:</b> Mors",
				"12|BRW-R-APO Rebirth Apocalypse: <b>Famine</b> Setup: None <b>Mages:</b> Fames, Bella, Venticello, Irene",
				"13|BRW-R-APO Rebirth Apocalypse: <b>Pestilence</b> Setup: Pestis and Infectio Tokens, Pestice Evocation cards for all players<b>Mages:</b> Pestilentia, Dai Jin",
				"14|BRW-R-APO Rebirth Apocalypse: <b>War</b> Setup: Apocalypse Equipments <b>Mages:</b> Bellum, Etns, Venticello, Irene",
				"15|BRW-R-FORGE Rebirth Dread Forge: <b>Forge</b> Setup: Forge Equipments and Upgrades, Pupa <b>Mages:</b> Angela, Etna",
				"16|BRW-R-GAEA Rebirth Gaea Reborn: <b>Geomancy</b> Setup: None <b>Mages:</b> Talia, Venticello, Irene, Prospero",
				"17|DUEL-LEX Duel Lex: <b>Lex</b> Setup: Templarii, Lex Upgrades <b>Mages:</b> Bartholomaus, Ulrich, Hogwartz",
				"18|DUEL-VOID Duel Void: <b>Void</b> Setup: Dagon <b>Mages:</b> Aluce, Alhazred",
				"19|BRW-CORE BRW Core: <b>Conspiracy</b> Setup: None <b>Mages:</b> Geneve, Corax",
				"20|BRW-CORE BRW Core: <b>Destruction</b> Setup: Malacoda <b>Mages:</b> Nero, Vivian",
				"21|BRW-CORE BRW Core: <b>Divination</b> Setup: Divine Altar <b>Mages:</b> Jaf'ar",
				"22|BRW-CORE BRW Core: <b>Illusion</b> Setup: Andromedar <b>Mages:</b> Marco, Corax, D. Schiavon",
				"23|BRW-CORE BRW Core: <b>Necromancy</b> Setup: Landsknecht, Bone Knight; OPTIONAL: Cemetery Room to provide Landsknecht <b>Mages:</b> Rebecca, Skultor",
				"24|BRW-CORE BRW Core: <b>Transmutation</b> Setup: Abomination, Mutant Altar <b>Mages:</b> Tessa",
				"25|BRW-SATOR BRW SATOR: <b>Bardic</b> Setup: Landsknecht; OPTIONAL: BRW Core Cemetary Room to summon Landsknecht more easily <b>Mages:</b> Arthur Vox",
				"26|BRW-SATOR BRW SATOR: <b>Blood</b> Setup: Hashomer and its Action Cards, Poison Tokens <b>Mages:</b> Elizmbra",
				"27|BRW-SATOR BRW SATOR: <b>Cartomancy</b> Setup: MinoTower, Quest Tokens <b>Mages:</b> Baba Yaga",
				"28|BRW-SATOR BRW SATOR: <b>Chronomancy</b> Setup: Clockwork Golem <b>Mages:</b> Old Jukas, Telmia",
				"29|BRW-SATOR BRW SATOR: <b>Demonology</b> Setup: Kappa, Kyuubi no Kitsune, NureOna, Omi, Tengu <b>Mages:</b> Tora, Skultor",
				"30|BRW-SATOR BRW SATOR: <b>Elementalism</b> Setup: Chantico, Ehecatl, Itztli, Atlaua <b>Mages:</b> Ishuicole, Viviane",
				"31|BRW-SATOR BRW SATOR: <b>Enchantment</b> Setup: Dancing Blades, SATOR Equipments <b>Mages:</b> Bronte",
				"32|BRW-SATOR BRW SATOR: <b>Mind</b> Setup: Pigman <b>Mages:</b> Circe",
				"33|BRW-SATOR BRW SATOR: <b>Omnia</b> Setup: Ichabod the spoiled Cat <b>Mages:</b> Arianna, Bella",
				"34|BRW-SATOR BRW SATOR: <b>Trickery</b> Setup: Nimbo, Room Infestation Tokens, Bucket Equipment <b>Mages:</b> Dukas, Bella",
				"35|BRW-SATOR BRW SATOR: <b>Void</b> Setup: Dagon <b>Mages:</b> Howard, Old Jukas",
				"36|BRW-CRONO BRW Crono: <b>Myth</b> Setup: Disgrace of Crete, SATOR Equipment; OPTIONAL: Medusa <b>Mages:</b> Medusa",
				"37|BRW-REV-CORE Revised Core: <b>Conspiracy</b> Setup: None <b>Mages:</b> Geneve, Corax",
				"38|BRW-REV-CORE Revised Core: <b>Destruction</b> Setup: Malacoda <b>Mages:</b> Nero, Vivian",
				"39|BRW-REV-CORE Revised Core: <b>Divination</b> Setup: Divine Altar <b>Mages:</b> Jaf'ar",
				"40|BRW-REV-CORE Revised Core: <b>Illusion</b> Setup: Andromedar <b>Mages:</b> Marco, Corax, D. Schiavon",
				"41|BRW-REV-CORE Revised Core: <b>Necromancy</b> Setup: Landsknecht, Bone Knight; OPTIONAL: Cemetery Room to provide Landsknecht <b>Mages:</b> Rebecca, Skultor",
				"42|BRW-REV-CORE Revised Core: <b>Transmutation</b> Setup: Abomination, Mutant Altar <b>Mages:</b> Tessa",
				"43|BRW-REV-TENET Revised TENET: <b>Twilight</b> Setup: unknown",
				"44|BRW-REV-TENET Revised TENET: <b>Ritualism</b> Setup: unknown <b>Mages:</b> S'Arzadori",
				"45|REQ Requiem Crossover: <b>Totentanz</b> Setup: unknown",
				"46|BRW-DISCORD Discord Custom Items: <b>Legion</b> Setup: TBD; ask Thorbot <b>Mages:</b> Morningstar",
				"47|BRW-DISCORD Discord Custom Items: <b>Angelic</b> Setup: TBD; ask Chromium <b>Mages:</b> St. Boniface",
				"48|BRW-DISCORD Discord Custom Items: <b>Phyrexian</b> Setup: TBD; ask Montrovant <b>Mages:</b> Elesh Norn",
				"49|BRW-DISCORD Discord Custom Items: <b>Reflective</b> Setup: Both Bella mages from SATOR and ROTAS Once Upon a Time; ask HirkingS <b>Mages:</b> Bella",
				];

	    	var allmages =[
				"BRW-R-CORE Rebirth Core: Rikkart",
				"BRW-R-CORE Rebirth Core: Arianna",
				"BRW-R-CORE Rebirth Core: Gramigna",
				"BRW-R-CORE Rebirth Core: Baron Doria",
				"BRW-R-CORE-DM Rebirth Deadly Masks: Seifu",
				"BRW-R-CORE-DM Rebirth Deadly Masks: Angela",
				"BRW-R-ROTAS Rebirth ROTAS Antiquities: Cassandra",
				"BRW-R-ROTAS Rebirth ROTAS Last Dynasty: Imhotep",
				"BRW-R-ROTAS Rebirth ROTAS Last Dynasty: Saba",
				"BRW-R-ROTAS Rebirth ROTAS Madness: Landolfo II",
				"BRW-R-ROTAS Rebirth ROTAS North Winds: Kormac",
				"BRW-R-ROTAS Rebirth ROTAS Once Upon a Time: Hogwartz",	
				"BRW-R-ROTAS Rebirth ROTAS Once Upon a Time: Maelice",	
				"BRW-R-ROTAS Rebirth ROTAS Once Upon a Time: Venticello",
				"BRW-R-ROTAS Rebirth ROTAS Once Upon a Time: Bella",
				"BRW-R-ROTAS Rebirth ROTAS Silk Road: Alisha",	
				"BRW-R-ROTAS Rebirth ROTAS Silk Road: Pyotr",	
				"BRW-R-ROTAS Rebirth ROTAS Silk Road: Dai Jin",	
				"BRW-R-FORGE Rebirth Dread Forge: Etna",
				"BRW-R-GAEA Rebirth Gaea Reborn: Talia",
				"BRW-R-APO Rebirth Apocalypse: Mors",
				"BRW-R-APO Rebirth Apocalypse: Bellum",
				"BRW-R-APO Rebirth Apocalypse: Pestilentia",
				"BRW-R-APO Rebirth Apocalypse: Fames",
				"BRW-R-IRENE Rebirth Irene's Quest: Irene",
				"BRW-R-SOF Rebirth Seal of Fire: Prospero",
				"DUEL-LEX Duel Lex: Ulrich",
				"DUEL-LEX Duel Lex: Bartholom&auml;us",
				"DUEL-VOID Duel Void: Alhazred",
				"DUEL-VOID Dual Void: Alice",
				"BRW-CORE BRW Core: Nero", 
				"BRW-CORE BRW Core: Rebecca", 
				"BRW-CORE BRW Core: Tessa", 
				"BRW-CORE BRW Core: Jaf'ar", 
				"BRW-CORE-HT BRW Hidden Thorns: Geneve", 
				"BRW-CORE-HT BRW Hidden Thorns: Marco",
				"BRW-SATOR BRW SATOR: Corax",
				"BRW-SATOR BRW SATOR: Dukas",
				"BRW-SATOR BRW SATOR: Vivian",
				"BRW-SATOR BRW SATOR: Bella",
				"BRW-SATOR BRW SATOR: Arianna",
				"BRW-SATOR BRW SATOR: Skultor",
				"BRW-SATOR BRW SATOR: Old Man Jukas",
				"BRW-SATOR BRW SATOR: Eliumbra",
				"BRW-SATOR BRW SATOR: Tlahuicole",
				"BRW-SATOR BRW SATOR: Arthur Vox",
				"BRW-SATOR BRW SATOR: Baba Yaga",
				"BRW-SATOR BRW SATOR: Circe",
				"BRW-SATOR BRW SATOR: Bronte",
				"BRW-SATOR BRW SATOR: Tora",
				"BRW-SATOR BRW SATOR: Howard",
				"BRW-SATOR BRW SATOR: Davide Schiavon",
				"BRW-SATOR BRW SATOR: Telmia",
				"BRW-CRONO BRW Crono: Medusa",
				"ASHES Ashes Magazine: Cosma",
				"ASHES Ashes Magazine: Helblindi",
				"ASHES Ashes Magazine: Slenderman",
				"NA Nova Aetas Crossover: Agorix",
				"NA Nova Aetas Crossover: Boogeyman",
				"NA Nova Aetas Crossover: Onamor",
				"NA Nova Aetas Crossover: Hyperion",
				"NA Nova Aetas Crossover: Mediceo",
				"REQ Requiem Crossover: Istvan",
				"REQ Requiem Crossover: Herick",
				"BRW-REV-CORE Revised Core: Nero",
				"BRW-REV-CORE Revised Core: Jafar",
				"BRW-REV-CORE Revised Core: Tessa",
				"BRW-REV-CORE Revised Core: Rebecca",
				"BRW-REV-CORE-HT Revised Hidden Thorns: Marco",
				"BRW-REV-CORE-HT Revised Hidden Thorns: Geneve",
				"BRW-REV-TENET Revised TENET: Malombra",
				"BRW-REV-TENET Revised TENET: Efialte",
				"BRW-REV-TENET Revised TENET: S'Arzadori",
				"BRW-REV-TENET Revised TENET: Haruka",
				"BRW-REV-TENET Revised TENET: Jukas",
				"BRW-REV-TENET Revised TENET: Isadora",
				"BRW-REV-TENET Revised TENET: Elektra",
				"BRW-REV-TENET Revised TENET: Scarlatto",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Anubis",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Architect",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Cacus",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Fenrir",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Gaea",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Hastur",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Jukas",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Ignis",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Minotaurus",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Parcae",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Rubedo",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Janara",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Albedo",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Griphon",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Razvan",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Jack",
				"BRW-REB-CUSTCONV Rebirth Custom Conversion Kit:  Odin",
				"BRW-DISCORD Discord Custom Items: Morningstar",
				"BRW-DISCORD Discord Custom Items: St. Boneface",
				"BRW-DISCORD Discord Custom Items: Elesh Norn",
			
			];

	    		var allrooms = [
				"1|BRW-R-CORE (black): Rebirth Core: The Black Rose (black)#1",
				"2|BRW-R-GAEA (black): Rebirth Gaea Reborn: Emerald Rose (black)#1",
				"3|DUEL-LEX (black): Duel Lex: Occult Black Rose Room (black)#1",
				"4|DUEL-VOID (black): Duel Void: Deep Black Rose Room (black)#1",
				"5|BRW-CORE (black): BRW Core: The Black Rose (black)#1",
				"6|BRW-INFERNOX (black): BRW Inferno: Tartaro (black)#1",
				"7|BRW-REV-CORE (black): Revised Core: The Black Rose (black)#1",
				"8|BRW-CRONO (black): BRW Crono: Revenge Room (black)#1",
				"9|BRW-R-CORE (purple): Rebirth Core: Throne Room [crown](purple)#2",
				"10|BRW-R-CORE (purple): Rebirth Core: Pleasure Room (purple)#3",
				"11|BRW-R-CORE (purple): Rebirth Core: Armory (purple)#4",
				"12|BRW-R-ROTAS (purple): Rebirth ROTAS Once Upon a Time: Skull Throne Room [crown](purple)#2",
				"13|DUEL-LEX (purple): Duel Lex: Templars' Armory (purple)#4",
				"14|DUEL-VOID (purple): Duel Void: Ancient Pleasures' Room (purple)#3",
				"15|BRW-CORE (purple): BRW Core: Throne Room [crown](purple)#2",
				"16|BRW-CORE (purple): BRW Core: Pleasure Room (purple)#3",
				"17|BRW-CORE (purple): BRW Core: Armory (purple)#4",
				"18|BRW-SATOR (purple): BRW SATOR: Card's Room (purple)",
				"19|BRW-SATOR (purple): BRW SATOR: Pigmen's Room - Setup: Mutated Pigmen (purple)",
				"20|BRW-INFERNO (purple): BRW Inferno: Armory - infernal - Setup: Arpia (purple)#4",
				"21|BRW-INFERNO (purple): BRW Inferno: Pleasure Room - infernal - Setup: Arpia, Farfarello (purple)#3",
				"22|BRW-INFERNOX (purple): BRW Inferno: Cerchio dei Lussuriosi (purple)",
				"23|BRW-INFERNO (purple): BRW Inferno: Bolgia dei Ruffiani (purple)",
				"24|BRW-INFERNO (purple): BRW Inferno: Bolgia dei Ladri [crown](purple)#2",
				"25|BRW-CRONO (purple): BRW Crono: Room of Corrupt Power [crown](purple)#2",
				"26|BRW-REV-CORE (purple): Revised Core: Throne Room [crown](purple)#2",
				"27|BRW-REV-CORE (purple): Revised Core: Pleasure Room (purple)#3",
				"28|BRW-REV-CORE (purple): Revised Core: Armory (purple)#4",
				"29|BRW-R-CORE (red): Rebirth Core: Arena (red)#5",
				"30|BRW-R-CORE (red): Rebirth Core: Laboratory (red)#6",
				"31|BRW-R-CORE (red): Rebirth Core: Summoner Room - Setup: Nigredo (red)#7",
				"32|BRW-R-ROTAS (red): Rebirth ROTAS Antiquities: Ludus Magnus Arena - Setup: Aruspice (red)#5",
				"33|DUEL-LEX (red): Duel Lex: Crusaders' Summoner Room (red)#7",
				"34|DUEL-VOID (red): Duel Void: Lost Alchemical Laboratory (red)#6",
				"35|BRW-CORE (red): BRW Core: Arena (red)#5",
				"36|BRW-CORE (red): BRW Core: Laboratory (red)#6",
				"37|BRW-CORE (red): BRW Core: Summoner Room - Setup: Cerbero (red)#7",
				"38|BRW-SATOR (red): BRW SATOR: Assassin's Brotherhood - Setup: Ezio Auditore (red)",
				"39|BRW-SATOR (red): BRW SATOR: Garden of Ice and Fire (red)",
				"40|BRW-SATOR (red): BRW SATOR: Cyclop's Room - Setup: Artifact deck (red)",
				"41|BRW-INFERNO (red): BRW Inferno: Arena - infernal (red)#5",
				"42|BRW-INFERNO (red): BRW Inferno: Summoner Room - infernal - Setup: Cerbero (red)#7",
				"43|BRW-INFERNO (red): BRW Inferno: Porta dell'Inferno (red)",
				"44|BRW-INFERNO (red): BRW Inferno: Girone degli Omicidi - Setup: Centauro (red)",
				"45|BRW-INFERNO (red): BRW Inferno: Cerchio degli Iracondi (red)",
				"46|BRW-CRONO (red): BRW Crono: Sanctuary of Flames (red)",
				"47|BRW-FAMILIARS (red): BRW Familiars: Cerberus - Setup: Cerberus Familiars (red)",
				"47|BRW-REV-CORE (red): Revised Core: Arena (red)#5",
				"48|BRW-REV-CORE (red): Revised Core: Laboratory (red)#6",
				"49|BRW-REV-CORE (red): Revised Core: Summoner Room - Setup: Cerbero (red)#7",
				"50|BRW-R-CORE (green): Rebirth Core: Garden (green)#8",
				"51|BRW-R-CORE (green): Rebirth Core: Forge (green)#9",
				"52|BRW-R-CORE (green): Rebirth Core: Treasure Room (green)#10",
				"53|BRW-R-ROTAS (green): Rebirth ROTAS Silk Road: Zen Garden (green)#8",
				"54|BRW-R-GAEA (green): Rebirth Gaea Reborn: Thorny Clearing (green)",	
				"55|BRW-R-GAEA (green): Rebirth Gaea Reborn: Indoor Forrest (green)",	
				"56|BRW-R-GAEA (green): Rebirth Gaea Reborn: Life Fountain (green)",
				"57|DUEL-LEX (green): Duel Lex: Templars' Treasure Room (green)#10",
				"58|DUEL-VOID (green): Duel Void: Forge of the Void (green)#9",
				"59|BRW-CORE (green): BRW Core: Garden (green)#8",
				"60|BRW-CORE (green): BRW Core: Forge (green)#9",
				"61|BRW-CORE (green): BRW Core: Treasure Room (green)#10",
				"62|BRW-SATOR (green): BRW SATOR: Clinging Swamp (green)",
				"63|BRW-SATOR (green): BRW SATOR: Tana dei Troll (green)",
				"64|BRW-INFERNO (green): BRW Inferno: Garden - infernal (green)#8",
				"65|BRW-INFERNO (green): BRW Inferno: Treasure Room - infernal - Setup: Centauro (green)#10",
				"66|BRW-INFERNOX (green): BRW Inferno: Selva Oscura (green)",
				"67|BRW-INFERNO (green): BRW Inferno: Girone dei Bestemmiator (green)",
				"68|BRW-INFERNO (green): BRW Inferno: Cerchio dei Golosi - Setup: Cerbero (green)",
				"69|BRW-CRONO (green): BRW Crono: Training Room (green)",
				"70|BRW-FAMILIARS (green): BRW Familiars: Draco - Setup: Draco Familiars (green)",
				"71|BRW-REV-CORE (green): Revised Core: Garden (green)#8",
				"72|BRW-REV-CORE (green): Revised Core: Forge (green)#9",
				"73|BRW-REV-CORE (green): Revised Core: Treasure Room (green)#10",
				"74|BRW-R-CORE (yellow): Rebirth Core: Bibliotheca (yellow)#11",
				"75|BRW-R-CORE (yellow): Rebirth Core: Observatory (yellow)#12",
				"76|BRW-R-CORE (yellow): Rebirth Core: Sanctuary (yellow)#13",
				"77|BRW-R-ROTAS (yellow): Rebirth ROTAS Last Dynasty: Sanctuary of Anubis - Setup: Pharaoh (yellow)#13",
				"78|DUEL-LEX (yellow): Duel Lex: Bibliotheca of the Order (yellow)#11",
				"79|DUEL-VOID (yellow): Duel Void: Abyssal Observatory (yellow)#12",
				"80|BRW-CORE (yellow): BRW Core: Bibliotheca (yellow)#11",
				"81|BRW-CORE (yellow): BRW Core: Observatory (yellow)#12",
				"82|BRW-CORE (yellow): BRW Core: Sanctuary (yellow)#13",
				"83|BRW-SATOR (yellow): BRW SATOR: Alehouse (yellow)",
				"84|BRW-SATOR (yellow): BRW SATOR: Eerie Machinery (yellow)",
				"85|BRW-SATOR (yellow): BRW SATOR: Cyclop's Forge (yellow)",
				"86|BRW-INFERNO (yellow): BRW Inferno: Sanctuary - infernal (yellow)#13",
				"87|BRW-INFERNO (yellow): BRW Inferno: Bolgia dei Simoniaci (yellow)",
				"88|BRW-INFERNOX (yellow): BRW Inferno: Limbo (yellow)",
				"89|BRW-INFERNO (yellow): BRW Inferno: Cerchio degli Avari (yellow)",
				"90|BRW-CRONO (yellow): BRW Crono: Hell's Door - Setup: Bone Knight (yellow)",
				"91|BRW-FAMILIARS (yellow): BRW Familiars: Griffin - Setup: Griffin Familiars (yellow)",
				"92|BRW-REV-CORE (yellow): Revised Core: Bibliotheca (yellow)#11",
				"93|BRW-REV-CORE (yellow): Revised Core: Observatory (yellow)#12",
				"94|BRW-REV-CORE (yellow): Revised Core: Sanctuary (yellow)#13",
				"95|BRW-R-CORE (blue): Rebirth Core: The Abyss (blue)#14",
				"96|BRW-R-CORE (blue): Rebirth Core: Mirrors' Room (blue)#15",
				"97|BRW-R-CORE (blue): Rebirth Core: Oracle Room (blue)#16",
				"98|BRW-R-ROTAS (blue): Rebirth ROTAS North Winds: The Abyss of Hel - Setup: Crocodilus, Ursa (blue)#14",
				"99|DUEL-LEX (blue): Duel Lex: Abyss of Faith (blue)#14",
				"100|DUEL-VOID (blue): Duel Void: Blasphemous Oracle (blue)#16",
				"101|BRW-CORE (blue): BRW Core: The Abyss (blue)#14",
				"102|BRW-CORE (blue): BRW Core: Mirrors' Room (blue)#15",
				"103|BRW-CORE (blue): BRW Core: Oracle Room (blue)#16",
				"104|BRW-SATOR (blue): BRW SATOR: Horologium (blue)",
				"105|BRW-SATOR (blue): BRW SATOR: Theater (blue)",
				"106|BRW-INFERNO (blue): BRW Inferno: Oracle Room - infernal (blue)#16",
				"107|BRW-INFERNO (blue): BRW Inferno: The Abyss - infernal - Setup: Farfarello (blue)#14",
				"108|BRW-INFERNO (blue): BRW Inferno: Bolgia dei Barattieri - Setup: Farfarello (blue)",
				"109|BRW-INFERNO (blue): BRW Inferno: Cerchio dei Traditori (blue)",
				"110|BRW-INFERNO (blue): BRW Inferno: Bolgia dei Maghi (blue)",
				"111|BRW-FAMILIARS (blue): BRW Familiars: Hydra - Setup: Hydra Familiars (blue)",
				"112|BRW-REV-CORE (blue): Revised Core: The Abyss (blue)#14",
				"113|BRW-REV-CORE (blue): Revised Core: Mirrors' Room (blue)#15",
				"114|BRW-REV-CORE (blue): Revised Core: Oracle Room (blue)#16",
				"115|BRW-R-CORE (gray): Rebirth Core: Cemetery - Setup: Cadaver, Colossus (gray)#17",
				"116|BRW-R-CORE (gray): Rebirth Core: Crypt - Setup: Cadaver (gray)#18",
				"117|BRW-R-CORE (gray): Rebirth Core: Sacrificial Altar - Setup: Cadaver (gray)#19",
				"118|BRW-R-ROTAS (gray): Rebirth ROTAS Madness: Sacrificial Altar of Madness (gray)#19",
				"119|BRW-R-SOF (gray): Rebirth Seal of Fire: Room of Rebirth - Setup: Phoenix Familiars (gray)",
				"120|DUEL-LEX (gray): Duel Lex: Crypt of the Saint - Setup: Templarii (gray)#18",
				"121|DUEL-VOID (gray): Duel Void: Whales Cemetary - Setup: Dagon (gray)#17",
				"122|BRW-CORE (gray): BRW Core: Cemetery - Setup: Landsknecht (gray)#17",
				"123|BRW-CORE (gray): BRW Core: Crypt (gray)#18",
				"124|BRW-CORE (gray): BRW Core: Sacrificial Altar (gray)#19",
				"125|BRW-SATOR (gray): BRW SATOR: Cursed Temple - Setup: Landsknecht (gray)",
				"126|BRW-INFERNOX (gray): BRW Inferno: Cerchio degli Erefici (gray)",
				"127|BRW-INFERNO (gray): BRW Inferno: Antinferno (gray)",
				"128|BRW-INFERNO (gray): BRW Inferno: Girone dei Suicidi - Setup: Arpia (gray)",
				"129|BRW-INFERNO (gray): BRW Inferno: Cemetery - infernal - Setup: Landsknecht (gray)#17",
				"130|BRW-INFERNO (gray): BRW Inferno: Sacrificial Altar - infernal - Setup: Malacoda (gray)#19",
				"131|BRW-REV-CORE (gray): Revised Core: Cemetery (gray)#17",
				"132|BRW-REV-CORE (gray): Revised Core: Crypt - Setup: Landsknecht (gray)#18",
				"133|BRW-REV-CORE (gray): Revised Core: Sacrificial Altar (gray)#19",
			];

			var allavatars =[
				"BRW-R-CORE Rebirth Core: The Possessed (no dedicated model available)",
				"BRW-R-CORE Rebirth Core: Jukas or if not available use The Possessed (no dedicated model available)",
				"BRW-REV-CORE Revised Core: Slenderman (model from Ashes Magazine 11)",
				"BRW-REV-CORE Revised Core: Titonauta or if not available use Slenderman (model from Ashes Magazine 11)",
				"BRW-REV-TENET Revised TENET: Infamy of Crete",
				"BRW-REV-TENET Revised TENET: Caronte",
				"ASHES Ashes Magazine: The Architect (recommended for Duel games otherwise use The Possessed)",
				"BRW-R-ROTAS Rebirth ROTAS Antiquities: Cacus (2 Avatar cards)",
				"BRW-R-ROTAS Rebirth ROTAS Antiquities: Parcae",
				"BRW-R-ROTAS Rebirth ROTAS Last Dynasty: Anubis",
				"BRW-R-ROTAS Rebirth ROTAS Madness: Rubedo",
				"BRW-R-ROTAS Rebirth ROTAS North Winds: Odin",
				"BRW-R-ROTAS Rebirth ROTAS Once Upon a Time: Hastur",	
				"BRW-R-ROTAS Rebirth ROTAS Silk Road: Devi",
				"BRW-R-FORGE Rebirth Dread Forge: Etna",
				"BRW-R-GAEA Rebirth Gaea Reborn: Gaea",
				"REQ Requiem Crossover: Invaders",
				"BRW-DISCORD Discord Custom Items: Arianna (ask Teddy)",
	    		];
	    
		var colors =[
			"red", 
			"blue", 
			"green", 
			"yellow", 
			"white", 
			"purple"
		];

	    	var roomcolors =[
			"black",
			"red", 
			"blue", 
			"green", 
			"yellow", 
			"gray", 
			"purple"
		];
		
	  	// Show one or multiple error messages
  		function showErrors(messages) {
    		const box = document.getElementById('error-messages');
    		const list = Array.isArray(messages) ? messages : [messages];

    		box.innerHTML =
      			`<strong>There ${list.length === 1 ? 'was an error' : 'were errors'}:</strong>
       			<ul>${list.map(m => `<li>${m}</li>`).join('')}</ul>`;

    		box.classList.remove('hidden');
  		}

  		// Hide/clear errors
  		function clearErrors() {
    		const box = document.getElementById('error-messages');
   		 	box.classList.add('hidden');
    		box.textContent = '';
  		}    

		
	// ########################################################################################
	// ### Show a random Library build from selected BRW boxes
	// ########################################################################################		
 
    function displayLibrary(){
        let schools = []; 
	    var mages = [];
		var genrooms = [];
		var duprooms = [];
		var purplerooms = [];
		var avatars = [];
        var libraryHTML = "";
        var checkboxes = document.querySelectorAll('input[type=checkbox]:checked')
		var checkboxesVal = [];
		var scenarios = [];
		var honmen = [];
		var keepRooms = [];
		var keepSchools = [];
		
  		clearErrors();	
try { 
	
	// Get checkbox values as array
	for (var i = 0; i < checkboxes.length; i++) {
  		checkboxesVal.push(checkboxes[i].value)
	}

	
	
	if( components == 0 ) throw new Error("No component to generate selected. Select Scenario or at least one of the other options from School, Start Player, Mages, Lodge or Avatar!");
	if( checkboxes.length - components == 0 ) throw new Error("No BRW game boxes selected to pick setup items from. Select at least one game box! You may want to start with a core set.");

	if( !checkboxesVal.includes("SCENARIO") ) {
		if( checkboxesVal.includes("SCHOOL") || checkboxesVal.includes("PLAYER") || checkboxesVal.includes("MAGE") || checkboxesVal.includes("LODGE") || checkboxesVal.includes("AVATAR") ) {	
			libraryHTML += "<b>The Black Rose came up with this Setup for you:</b><p>";
		}
		else {
			libraryHTML += "<font color=#FF0000>Select at least one out of Schools, Start Player, Mages, the Lodge or Avatar to generate!</font><p>";
		}
	}
		
	libraryHTML += "<div style='padding-left:20px;'>";


	// ########################
	// ######################## SCENARIO 
	// ########################			
	if( checkboxesVal.includes("SCENARIO") ) {

		// Select scenarios for selected boxes
        for (let i = 0; i < allscenarios.length; i++) {
			if( allscenarios[i].split(" ")[0] == "*" ) {
					scenarios.push( allscenarios[i].substring(allscenarios[i].indexOf('|')+1) );
			}
			for (let j = 0; j < checkboxes.length; j++) {
				if( allscenarios[i].split(" ")[0] == checkboxes[j].value ) {
					scenarios.push( allscenarios[i].substring(allscenarios[i].indexOf('|')+1) );
				}
			}
        }

		// Select honorable mention
        for (let i = 0; i < allhonmen.length; i++) {
			if( allhonmen[i].split(" ")[0] == "*" ) {
					honmen.push( allhonmen[i].substring(allhonmen[i].indexOf('|')+1) );
			}
			for (let j = 0; j < checkboxes.length; j++) {
				if( allhonmen[i].split(" ")[0] == checkboxes[j].value ) {
					honmen.push( allhonmen[i].substring(allhonmen[i].indexOf('|')+1) );
				}
			}
        }

		shuffleArray(scenarios);
		const sName = scenarios[0].split("|")[0];
		const sComp = scenarios[0].split("|")[1];
		var sSetup = scenarios[0].split("|")[2];
		const sRules = scenarios[0].split("|")[3];
		const sHonMen = scenarios[0].split("|")[4];
		
		libraryHTML += "<p><b>Scenario:</b> " + sName + "</p>";
		libraryHTML += "<p><b>Additional Components:</b></p><p>" + sComp + "</p>";

		// Find enforced rooms
		if(sSetup.indexOf("Rooms: (")>=0) {
			const sRooms = sSetup.split("Rooms: (")[1].split(")")[0].split(",").map(s => s.trim());
			var collRooms = "";
			var roomLine = "";
			for (let i = 0; i < sRooms.length; i++) {
				keepRooms.push(sRooms[i]);
				roomLine = getArrayById(sRooms[i], allrooms);
				collRooms += roomLine.substring(roomLine.indexOf(':', roomLine.indexOf(':') + 1) + 1).substring(1).split("(")[0].trim().split(" - Setup:")[0];
				if(i<sRooms.length-1) collRooms += ", ";
				// alert("Generator: " + collRooms);
			}
			
			// Replace content inside parentheses
			sSetup = sSetup.replace(/Rooms:\s*\([^)]*\)/, `<li><b>Fixed Rooms:</b> ${collRooms}`);
		}

		// Find enforced schools
		if(sSetup.indexOf("Schools: (")>=0) {
			const sSchools = sSetup.split("Schools: (")[1].split(")")[0].split(",").map(s => s.trim());
			var collSchools = "";
			var schoolLine = "";
			for (let i = 0; i < sSchools.length; i++) {
				keepSchools.push(sSchools[i]);
				schoolLine = getArrayById(sSchools[i], allschools);
				collSchools += schoolLine.split("<b>")[1].split("</b>")[0].trim();
				if(i<sSchools.length-1) collSchools += ", ";
				// alert("Generator: " + collRooms);
			}
			
			// Replace content inside parentheses
			sSetup = sSetup.replace(/Schools:\s*\([^)]*\)/, `<li><b>Fixed Schools:</b> ${collSchools}`);
		}
			
		libraryHTML += "<p><b>Special Setup:</b></p><p>" + sSetup + "</p>";
		libraryHTML += "<div class='board' id='board'></div>";
		
		libraryHTML += "<p><b>Rules:</b></p><p>" + sRules + "</p>";

		
		// Honorable Mention
		libraryHTML += "<p><b>Honorable Mention:</b></p>";
		if(sHonMen=="*") {
			shuffleArray(honmen);
			const numhonmen = Math.floor(Math.random()*3+2);

			libraryHTML += "<p><ul>";
			for (let i = 0; i < numhonmen; i++) {
				libraryHTML += "<li><b>" + honmen[i].split("|")[0].split(":")[0] + ":</b>" + honmen[i].split("|")[0].split(":")[1] + "</li>"; 
			}			
			libraryHTML += "</ul></p>";
			
		} else {
			libraryHTML += "<p>" + sHonMen + "</p>";
		}
		libraryHTML += "<hr>";
	}
	
	// ########################################################################################
	// ### SCHOOL setup
	// ########################################################################################
	// ### - Respects keepSchools from scenario to enforce certain schools
	// ###
	// ########################################################################################
	
	var schoolHTML = "";
	
	if( checkboxesVal.includes("SCHOOL") || checkboxesVal.includes("SCENARIO") ) {
		
	    // Add schools based on selected BRW boxes
        for (let i = 0; i < allschools.length; i++) {
			for (let j = 0; j < checkboxes.length; j++) {
				if(checkboxes[j].value == allschools[i].split(" ")[0].split("|")[1]) {
					schools.push(allschools[i]);
				}
			}
        }

		// Remove duplicate school names
		shuffleArray(schools);
		schools = uniqe_school(schools, keepSchools);
		
		// Remove random schools until only 6 remain, respecting keepSchools
		while (schools.length > 6) {
    		// build a list of removable indices
    		let removable = [];
    		for (let i = 0; i < schools.length; i++) {
        		const id = schools[i].split("|")[0]; // assume ID is before '|'
        		if (!keepSchools.includes(id)) removable.push(i);
    		}

    		// if nothing can be removed, break to avoid infinite loop
    		if (removable.length === 0) break;

    		// pick a random removable school and remove it
    		const randIdx = removable[Math.floor(Math.random() * removable.length)];
    		schools.splice(randIdx, 1);
		}

		// Show Library as HTML table				
		if(schools.length<6) throw new Error("Not enough schools available. Select more BRW boxes to choose schools from!");
		
		schoolHTML += "<table><tr><th align=left width=250>BOX</th><th align=left width=135>SCHOOL</th><th align=left>SETUP</th></tr>";
        for (let i = 0; i < schools.length; i++) {
			schools[i] = schools[i].substring(schools[i].indexOf(' ') + 1);
			schools[i] = schools[i].replace("Setup: ","</td><td style='vertical-align:top'>");
			schools[i] = schools[i].replace(": <b>"," </td><td style='vertical-align:top'><b>");
            schoolHTML += "<tr><td style='vertical-align:top'>" + schools[i] + "</td></tr>";
        }
		schoolHTML += "</table>";
		
		libraryHTML += schoolHTML;
	}

	if( checkboxesVal.includes("PLAYER") ) {	
		// start player
		shuffleArray(colors);
		libraryHTML += "<b>Start player: </b>";
		for (let i = 0; i < colors.length; i++) {
			if(i!=0) libraryHTML += " &gt; ";
			libraryHTML += "<span style='color: " + colors[i] + ";background-color: #aaaaaa;'>" + colors[i] + "</span>";
		}
		libraryHTML += "<p>";
	}

	if( checkboxesVal.includes("MAGE") ) {	
		
		// Random mages
		libraryHTML += "<b>Random Mages:</b> Either draft them or assign them in the order of schools or players from above.<p>";
		
		// Select mages from selected boxes
            for (let i = 0; i < allmages.length; i++) {
		for (let j = 0; j < checkboxes.length; j++) {
			if( allmages[i].split(" ")[0] == checkboxes[j].value ) {
				mages.push( "<b>" + allmages[i].substring(allmages[i].indexOf(':') + 1) + "</b> (" + allmages[i].split(":")[0].substring(allmages[i].indexOf(' ') + 1) + ")" );
			}
		}
            }

		// Remove duplicate school names
		shuffleArray(mages);
		mages = uniqe_mage(mages);
		
		// Remove random mage until only 6 remain
            	while(mages.length > 6) {
                	mages.splice(Math.floor(Math.random()*mages.length), 1);	
           	}
		shuffleArray(mages);

		// Show mages			
		if(mages.length<6) {
			libraryHTML += "<font color=#FF0000>Select more BRW boxes to provide at least 6 mages!</font>";
		} else {
			for (let i = 0; i < mages.length; i++) {
                 		libraryHTML += mages[i];
				if(i!=mages.length-1) libraryHTML += ", ";
            		}
		}		
		
		libraryHTML += "<p>";
	}

	if( checkboxesVal.includes("LODGE") ) {	
		
		// Random rooms
		// libraryHTML += "<b>Random Rooms:</b><br>";

		// Select rooms from selected boxes
        for (let i = 0; i < allrooms.length; i++) {
			for (let j = 0; j < checkboxes.length; j++) {
				if( allrooms[i].split(" ")[0].split("|")[1] == checkboxes[j].value ) {
					// duprooms.push(allrooms[i].substring(allrooms[i].indexOf('(') + 1));
					duprooms.push(allrooms[i]);
					if( allrooms[i].indexOf("(purple)")>0 ) purplerooms.push(allrooms[i]);
				}
			}
        }

		// Deduplicate randomly same # number rooms
		
/*		var rc=0;
		var delroom=0;
		var foundrooms=0;
		var hashval="";
		
        for (let i = 0; i < duprooms.length; i++) {
			rc=0;
			hashval=duprooms[i].split("#")[1];
			// libraryHTML += duprooms[i] + "'" + hashval + "'<br>";

			if( duprooms[i].indexOf("#") >= 0 )
			{	
				for (let j = 0; j < duprooms.length; j++) {
					if( duprooms[j].split("#")[1] == hashval ) rc++;
				}
				if( rc > 1 ) {
					delroom = Math.floor(Math.random()*rc)+1;
					foundrooms=0;
					for (let j = 0; j < duprooms.length; j++) {
						if( duprooms[j].split("#")[1] == hashval ) {
							foundrooms++;
							if( foundrooms == delroom ) genrooms.push(duprooms[j]);
							duprooms.splice(j,1);
							j=-1;
							i=-1;
						}
					}
				} else {
					genrooms.push(duprooms[i]);
					duprooms.splice(i,1);
					i=-1;
				}
			} else {
				genrooms.push(duprooms[i]);
				duprooms.splice(i,1);
				i=-1;
			}
		} */
		let groups = {};

		// group duprooms by hash value
		for (let i = 0; i < duprooms.length; i++) {
  			let item = duprooms[i];
  			let [id, rest] = item.split("|");
  			let parts = rest.split("#");
  			let base = parts[0];
  			let hashval = parts[1] || base; // use # value if present, otherwise unique base

  			if (!groups[hashval]) groups[hashval] = [];
  			groups[hashval].push({ id, item });
		}

		// now process each group
		for (let key in groups) {
  			let arr = groups[key];

  			// check if group contains any keepRooms
  			let kept = arr.filter(r => keepRooms.includes(r.id));

  			if (kept.length > 0) {
    			// keep *all* forced rooms
    			kept.forEach(r => genrooms.push(r.item));
  			} else {
    			// pick one random entry
    			let pick = arr[Math.floor(Math.random() * arr.length)];
    			genrooms.push(pick.item);
  			}
		}

		// Remove random rooms until only 1 black and 3 of each color remain
		
/*        for (let i = 0; i < roomcolors.length; i++) {
		    do {
			rc=0;
			for (let j = 0; j < rooms.length; j++) {
				if( rooms[j].split(")")[0].split("(")[1] == roomcolors[i] ) rc++;
			}
			if( (roomcolors[i] == "black" && rc > 1) || (roomcolors[i] != "black" && rc > 3) ) {
				delroom = Math.floor(Math.random()*rc)+1;
				// while( rooms.split("#")[1] == 2 ) delroom = Math.floor(Math.random()*rc)+1;
				foundrooms=0;
				for (let j = 0; j < rooms.length; j++) {
					if( rooms[j].split(")")[0].split("(")[1] == roomcolors[i] ) {
						foundrooms++;
						if( foundrooms == delroom && rooms[j].split("#")[1] != 2 ) {
							rooms.splice(j, 1);
							rc--;
							j--;
						}
					}
				}
			}
		    } while ( (roomcolors[i] == "black" && rc > 1) || (roomcolors[i] != "black" && rc > 3) );
		}
  */
		
for (let color of roomcolors) {
  // split rooms into this color and others
  let colorRooms = genrooms.filter(r => r.split(")")[0].split("(")[1] === color);
  let otherRooms = genrooms.filter(r => r.split(")")[0].split("(")[1] !== color);

  let maxAllowed = (color === "black" ? 1 : 3);

  // separate protected and non-protected
  let protectedRooms = colorRooms.filter(r => {
    let id = r.split("|")[0];
    let hash = r.split("#")[1];
    return hash == 2 || keepRooms.includes(id);
  });
  let nonProtectedRooms = colorRooms.filter(r => !protectedRooms.includes(r));

  // randomly remove non-protected rooms until maxAllowed is satisfied
  while (protectedRooms.length + nonProtectedRooms.length > maxAllowed) {
    if (nonProtectedRooms.length > 0) {
      let idx = Math.floor(Math.random() * nonProtectedRooms.length);
      nonProtectedRooms.splice(idx, 1);
    } else {
      // remove protected if necessary
      let idx = Math.floor(Math.random() * protectedRooms.length);
      protectedRooms.splice(idx, 1);
    }
  }

  // rebuild rooms array
  genrooms = otherRooms.concat(protectedRooms, nonProtectedRooms);
}


// create a lookup for color order
const colorOrder = {};
for (let i = 0; i < roomcolors.length; i++) {
  colorOrder[roomcolors[i]] = i;
}

// sort rooms based on the color order
genrooms.sort((a, b) => {
  const colorA = a.split(")")[0].split("(")[1];
  const colorB = b.split(")")[0].split("(")[1];
  return colorOrder[colorA] - colorOrder[colorB];
});
		
		// Inferno: Pleasure Room needs at least one oter room to summon Cerbero or Centauro
		// "BRW-INFERNO (purple): BRW Inferno: Pleasure Room - infernal - Setup: Arpia, Farfarello (purple)#3",
		var foundInfernalPleasure = -1;
		var foundSupportRoom = false;
		for (let i = 0; i < genrooms.length; i++) {
			if( genrooms[i].indexOf("Cerbero")>0 || genrooms[i].indexOf("Centauro")>0 ) {
				foundSupportRoom = true;
			}
			if( genrooms[i].indexOf("BRW Inferno: Pleasure Room - infernal")>0 ) {
				foundInfernalPleasure = i;
			}
		}
		if( foundSupportRoom == false && foundInfernalPleasure>0 ) {
			// no supporting room, Pleasure Room - infernsl must be replaced
			// genrooms.splice(foundInfernalPleasure, 1);
			
			for (let i = 0; i < purplerooms.length; i++) {
				if( ( (purplerooms[i].indexOf("#")>0 && purplerooms[i].split("#")[1]==3) 
				      || purplerooms[i].indexOf("#")<=0
				    ) && purplerooms[i].indexOf("BRW Inferno: Pleasure Room - infernal")<=0
				  ) {
					// found possible replacement, now check if already contained in Lodge
					// genrooms[foundInfernalPleasure]=purplerooms[i].substring(purplerooms[i].indexOf('(') + 1);
					var containsRoomAlready=false;
					for (let j = 0; j < genrooms.length; j++) {
						if( genrooms[j] == purplerooms[i] ) containsRoomAlready=true;
					}
				    if( !containsRoomAlready ) {
						genrooms[foundInfernalPleasure] = purplerooms[i];
						//genrooms[foundInfernalPleasure] = purplerooms[i].replaceAll("purple","black");
					}
					// genrooms.push( purplerooms[i] );
					// genrooms[foundInfernalPleasure]="purple): REPLACEMENT (purple)";
				}
			}
		}
		
		// Output rooms
		var roomHTML = "";
		var roomoutPre = "";
		var roomout = "";
		var colorout = "";
		var roomname = "";
		var roomhash = "";
		
		if(genrooms.length<19) {
			roomHTML += "<font color=#FF0000>Select more BRW boxes to provide at least 19 rooms!</font>";
		} else {
			roomHTML += "<table><tr><th align=left width=250>BOX</th><th align=left width=300>ROOM</th><th align=left width=200>SETUP</th></tr>";

			// Fill rooms for the rendering component
			rooms.length = 0;
			
			for (let i = 0; i < genrooms.length; i++) {
				roomHTML += "<tr><td>";
				roomhash = genrooms[i].includes("#") ? "#" + genrooms[i].split("#")[1] : "";
                roomHTML += genrooms[i].substring(genrooms[i].indexOf(':') + 1).split(":")[0];
				roomHTML += "</td><td>";
				roomout = "<b>" + genrooms[i].substring(genrooms[i].indexOf(':', genrooms[i].indexOf(':') + 1) + 1).substring(1);
				colorout = roomout.split("(")[1].split(")")[0];
				roomHTML += "<span style='color: " + colorout + ";background-color: #aaaaaa;'>" + colorout + "</span> ";
				
				// filter setup instructions
				if(roomout.indexOf(" - Setup:")>0) {
					roomname = roomout.split(" - Setup:")[0].split("(")[0].split("<b>")[1].trim();
					roomHTML += roomout.split(" - Setup:")[0].split("(")[0] + "</b>";
					roomHTML += "</td><td>";
					roomHTML += roomout.split(" - Setup:")[1].split("(")[0];
				} else {
					roomname = roomout.split("(")[0].split("<b>")[1].trim();
					roomHTML += roomout.split("(")[0] + "</b>";
					roomHTML += "</td><td>";
				}
				roomHTML += "</td></tr>";

				rooms.push(roomname + roomhash + "|" + colorout);
				// if(i!=rooms.length-1) libraryHTML += ", ";
            }
			roomHTML += "</table>";
		}
		roomHTML += "<p>";	
		libraryHTML += roomHTML;
	}
		
	if( checkboxesVal.includes("AVATAR") ) {	
		
		// Random Avatar
		
		// Select avatars from selected boxes
        for (let i = 0; i < allavatars.length; i++) {
			for (let j = 0; j < checkboxes.length; j++) {
				if( allavatars[i].split(" ")[0] == checkboxes[j].value ) {
					avatars.push( "<b>Random Avatar from " + allavatars[i].split(":")[0].substring(allavatars[i].indexOf(' ') + 1) + ": " + allavatars[i].substring(allavatars[i].indexOf(':') + 1) + "</b>" );
				}
			}
        }
		
		// Pick first random
		shuffleArray(avatars);

		// Show avatar			
		if(avatars.length<1) {
				libraryHTML += "<font color=#FF0000>Select more BRW boxes to provide at least 1 avatar!</font>";
		} else {
                 		libraryHTML += avatars[0];
		}
		libraryHTML += "<p>";
	}
			
	libraryHTML += "</div><p>";

    document.getElementById("result").innerHTML = libraryHTML;

} catch (e) {
	showErrors(e.message);
	// "<font color=#FF0000>Select more BRW boxes to choose schools from!</font><p>";
    alert("Generator error: " + e.message);
    // console.error(e);
  }

	// wait until DOM is painted
	requestAnimationFrame(() => {
    	createAndRender();
	});
		
}

function ruleTip() {
	var libraryHTML = "";

	// Rule tip
	libraryHTML += "<b>Rebirth rule tip "; 
	libraryHTML += rules[Math.floor(Math.random()*rules.length)].replaceAll("[b]","<b>").replaceAll("[/b]","</b>").replace("</b>. ","</b><p><div style='padding-left:20px;'><font color=#000099>").replace(".",":</b>");
	libraryHTML += "</font></div><p>";
		    
	document.getElementById("result").innerHTML = libraryHTML;
}

	// Return entry of an array by its id
	function getArrayById(id, arr) {
  		return arr.find(item => item.startsWith(id + "|")) || null;
	}

function shuffleArray(array) {
   		 for (let i = array.length - 1; i > 0; i--) {
       			 const j = Math.floor(Math.random() * (i + 1));
        		[array[i], array[j]] = [array[j], array[i]];
   		 }
}
/*
	function uniqe_school(a) {
		var seen = {};
    		var out = [];
    		var len = a.length;
    		var j = 0;
    		for(var i = 0; i < len; i++) {
         		var item = a[i].split("<b>")[1].split("</b>")[0];
         		if(seen[item] !== 1) {
               		seen[item] = 1;
               		out[j++] = a[i];
         		}
    		}
    		return out;
	}
*/

function uniqe_school(a, keep) {
    const seen = {};
    const out = [];

    for (let i = 0; i < a.length; i++) {
        const item = a[i];
        const id = item.split("|")[0]; // extract ID before '|'
        const name = item.split("<b>")[1].split("</b>")[0]; // extract name

        // always keep if ID is in keepSchools
        if (keep.includes(id)) {
            out.push(item);
            continue;
        }

        // keep only unique names otherwise
        if (!seen[name]) {
            seen[name] = true;
            out.push(item);
        }
    }

    return out;
}

	function uniqe_mage(a) {
		var seen = {};
    		var out = [];
    		var len = a.length;
    		var j = 0;
    		for(var i = 0; i < len; i++) {
         		var item = a[i].split("<b>")[1].split("</b>")[0];
         		if(seen[item] !== 1) {
               		seen[item] = 1;
               		out[j++] = a[i];
         		}
    		}
    		return out;
	}


/* ============================
   CONFIG: one-dimensional rooms[] strings "Name|color"
   Replace these placeholders with your real room names if desired.
   Must include exactly 19 entries and exactly one "Black Rose Room|black"
   and exactly one "Throne Room|purple".
   Colors allowed: black, purple, red, green, blue, gray, yellow
   ============================ */

/* ======= Validation of rooms[] counts ======= */
const REQUIRED_COUNTS = { black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3 };
(function validateRoomList() {
  if (!Array.isArray(rooms) || rooms.length !== 19) {
    throw new Error("rooms[] must be an array of 19 strings in format 'Name|color'.");
  }
  const parsed = rooms.map(s => {
    if (typeof s !== 'string' || !s.includes('|')) throw new Error("Each rooms[] entry must be 'Name|color'.");
    const [name, color] = s.split('|').map(x=>x.trim());
    return {name, color};
  });
  const counts = {};
  parsed.forEach(r => { counts[r.color] = (counts[r.color]||0) + 1; });
  for (const col of Object.keys(REQUIRED_COUNTS)) {
    if ((counts[col] || 0) !== REQUIRED_COUNTS[col]) {
      throw new Error(`Color counts mismatch: need ${REQUIRED_COUNTS[col]} ${col} rooms (found ${counts[col]||0}).`);
    }
  }
  // Ensure exactly one Black Rose Room and one Throne Room by name
  const names = parsed.map(p=>p.name);
  if (names.filter(n => n.endsWith("#1")).length !== 1) throw new Error("Must include exactly one 'Black Rose Room' entry.");
  if (parsed.filter(p => p.name.endsWith("#2") && p.color === "purple").length !== 1) throw new Error("Must include exactly one 'Throne Room|purple' entry.");
})();

/* =========================
   Hex utilities (axial coords, pointy)
   ========================= */
const DIRS = [ [1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1] ];
function key(q,r){ return `${q},${r}`; }
function unkey(k){ const [q,r] = k.split(',').map(Number); return {q,r}; }
function neighbors(q,r){ return DIRS.map(([dq,dr]) => [q+dq, r+dr]); }
function axialDistance(a,b){ const dq=a.q-b.q, dr=a.r-b.r, ds=-a.q-a.r + b.q + b.r; return (Math.abs(dq)+Math.abs(dr)+Math.abs(ds))/2; }
const MAX_RADIUS = 3;
function withinRadius(q,r){ return axialDistance({q,r},{q:0,r:0}) <= MAX_RADIUS; }

/* Axial -> pixel (pointy topped) */
const HEX_SIZE = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'));
const HEX_W = Math.sqrt(3)*HEX_SIZE;
const HEX_H = 2*HEX_SIZE;
/*function axialToPixel(q,r){
  const x = HEX_SIZE * Math.sqrt(3) * (q + r/2);
  const y = HEX_SIZE * 1.5 * r;
  return {x,y};
}*/

function axialToPixel(q, r){
  const x0 = HEX_SIZE * Math.sqrt(3) * (q + r/2);
  const y0 = HEX_SIZE * 1.5 * r;

  // 90° clockwise rotation
  const x = y0;
  const y = -x0;
  return {x, y};
}

/* ===== build full radius-3 set and rings ===== */
function buildFullSet(){
  const set = new Set();
  for (let q=-MAX_RADIUS;q<=MAX_RADIUS;q++){
    for (let r=-MAX_RADIUS;r<=MAX_RADIUS;r++){
      if (withinRadius(q,r)) set.add(key(q,r));
    }
  }
  return set; // should be 37 keys
}
function ringKeys(dist){
  const out = [];
  for (const k of buildFullSet()){
    const {q,r}=unkey(k);
    if (axialDistance({q,r},{q:0,r:0}) === dist) out.push(k);
  }
  return out;
}

/* ===== helper graph functions (for small graphs; simple BFS checks) ===== */
function buildAdjMap(keysSet){
  const adj = new Map();
  for (const k of keysSet) adj.set(k, []);
  for (const k of keysSet){
    const {q,r} = unkey(k);
    for (const [nq,nr] of neighbors(q,r)){
      const nk = key(nq,nr);
      if (keysSet.has(nk)) adj.get(k).push(nk);
    }
  }
  return adj;
}
function isConnected(keysSet){
  if (keysSet.size === 0) return true;
  if (!keysSet.has(key(0,0))) return false;
  const adj = buildAdjMap(keysSet);
  const start = key(0,0);
  const seen = new Set([start]); const stack = [start];
  while (stack.length){
    const cur = stack.pop();
    for (const nb of adj.get(cur)){
      if (!seen.has(nb)) { seen.add(nb); stack.push(nb); }
    }
  }
  return seen.size === keysSet.size;
}
function minDegreeAtLeast(keysSet, minDeg){
  const adj = buildAdjMap(keysSet);
  for (const [k, nb] of adj){
    if (k === key(0,0)) continue; // allow center exemption if you want; but center will usually have many neighbors
    if (nb.length < minDeg) return false;
  }
  return true;
}
/* articulation check: brute-force for small graph: removing one node and test connectivity */
function hasNoArticulationExceptCenter(keysSet){
  if (!isConnected(keysSet)) return false;
  for (const k of keysSet){
    if (k === key(0,0)) continue;
    const copy = new Set(keysSet);
    copy.delete(k);
    if (!isConnected(copy)) return false;
  }
  return true;
}

/* hole isolation rule:
   For every removed cell (in fullSet but not in shape), it must not be surrounded by all 6 present tiles.
   i.e., at least one of its 6 neighbors must also be missing or outside radius
*/
function noIsolatedHole(fullSet, shapeSet){
  for (const k of fullSet){
    if (shapeSet.has(k)) continue; // only examine holes
    const {q,r} = unkey(k);
    let neighborsPresent = 0;
    for (const [nq,nr] of neighbors(q,r)){
      const nk = key(nq,nr);
      if (shapeSet.has(nk)) neighborsPresent++;
    }
    if (neighborsPresent === 6) return false; // isolated hole
  }
  return true;
}

/* ========= Build candidate mirror pairs in rings 2 & 3 ========= */
function buildCandidatePairs(fullSet){
  const candidates = [];
  const blocked = new Set([key(0,0), ...ringKeys(1)]); // never remove center or ring1
  const visited = new Set();
  for (const k of fullSet){
    if (blocked.has(k)) continue;
    if (visited.has(k)) continue;
    const {q,r} = unkey(k);
    const mk = key(-q,-r);
    if (!fullSet.has(mk)) continue; // safety
    visited.add(k); visited.add(mk);
    // canonical ordering to avoid duplicates: only add if k < mk lexicographically
    if (k < mk) candidates.push([k,mk]);
    else candidates.push([mk,k]); // still ensure unique pair
  }
  return candidates; // should be 15 pairs (since 30 removable tiles)
}

/* ====== Choose exactly removePairsNeeded mirror pairs such that final shape meets graph constraints ====== */
function chooseRemovalPairCombination(fullSet, candidates, removePairsNeeded){
  // backtracking choose subset of candidates size removePairsNeeded
  // we try to prune aggressively: after partial selection, ensure current tentative shape has no vertex deg<2 (because removing more won't increase degree)
  // and remains connected.
  const totalPairs = candidates.length;

  // Shuffle candidate order to vary results
  shuffle(candidates);

  const selected = [];
  let result = null;
  const targetRemovals = removePairsNeeded * 2;

  function buildShapeFromSelected(selPairs){
    const shape = new Set(fullSet);
    for (const [a,b] of selPairs){
      shape.delete(a); shape.delete(b);
    }
    return shape;
  }

  function pruneCheck(selPairs){
    const shape = buildShapeFromSelected(selPairs);
    // quick prune: if any non-center vertex already has degree < 2 -> cannot be fixed later
    if (!minDegreeAtLeast(shape, 2)) return false;
    // must remain connected at this partial stage as well
    if (!isConnected(shape)) return false;
    // hole-isolation check for currently removed holes:
    // For any removed cell, if it's isolated (all 6 neighbors present in shape), it's a bad hole already (cannot be fixed)
    const full = fullSet;
    if (!noIsolatedHole(full, shape)) return false;
    // OK so far
    return true;
  }

  function backtrack(startIndex){
    if (result) return true;
    if (selected.length === removePairsNeeded){
      // final shape
      const finalShape = buildShapeFromSelected(selected);
      if (finalShape.size !== (fullSet.size - targetRemovals)) return false;
      // final checks: connectivity already checked earlier; do biconnectivity test (no articulation except center)
      if (!hasNoArticulationExceptCenter(finalShape)) return false;
      // final hole check
      if (!noIsolatedHole(fullSet, finalShape)) return false;
      result = finalShape;
      return true;
    }
    // If not enough candidates left to fill slots -> prune
    if (startIndex >= totalPairs) return false;
    const need = removePairsNeeded - selected.length;
    if (totalPairs - startIndex < need) return false;

    for (let i = startIndex; i < totalPairs; i++){
      selected.push(candidates[i]);
      // prune
      if (pruneCheck(selected)){
        if (backtrack(i+1)) return true;
      }
      selected.pop();
    }
    return false;
  }

  if (backtrack(0)) return result;
  return null;
}

/* ===== color assignment backtracking ===== */
const COLOR_COUNTS = { black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3 };
function assignColorsToShape(shapeSet, throneKey){
  const nodes = [...shapeSet];
  const adj = buildAdjMap(shapeSet);

  // fixed assignments
  const colorOf = new Map();
  const counts = JSON.parse(JSON.stringify(COLOR_COUNTS));
  colorOf.set(key(0,0), 'black'); counts.black--;
  colorOf.set(throneKey, 'purple'); counts.purple--;

  // sort nodes by degree descending, but ensure center and throne excluded
  const toColor = nodes.filter(n => n !== key(0,0) && n !== throneKey)
                       .sort((a,b) => adj.get(b).length - adj.get(a).length);

  function backtrack(i){
    if (i >= toColor.length) return true;
    const node = toColor[i];
    const used = new Set(adj.get(node).map(n => colorOf.get(n)).filter(Boolean));
    // try colors with remaining counts and not used by adjacent
    const choices = Object.keys(counts).filter(c => counts[c] > 0 && !used.has(c));
    // randomize order a bit to generate varied layouts
    shuffle(choices);
    for (const c of choices){
      colorOf.set(node, c);
      counts[c]--;
      // early neighbor-same-color constraint satisfied by used set already
      // Also quick feasibility: ensure remainings counts can fill remaining nodes (trivial here)
      if (backtrack(i+1)) return true;
      counts[c]++; colorOf.delete(node);
    }
    return false;
  }

  return backtrack(0) ? colorOf : null;
}

/* ===== mapping room strings to positions (preserve Throne and Black Rose exactly) ===== */
function mapRoomsToPositions(colorMap, throneKey){
  // parse rooms[] into pools
  const pools = {}; // color -> array of names
  for (const s of rooms){
    const [nameRaw, colorRaw] = s.split('|').map(x => x.trim());
    if (!pools[colorRaw]) pools[colorRaw] = [];
    pools[colorRaw].push(nameRaw);
  }
  // ensure Black Rose Room assigned to center
  const roomByPos = new Map();
  // center:
  const centerList = pools['black'] || [];
  const brIndex = centerList.findIndex(n => n.endsWith("#1"));
  if (brIndex === -1) throw new Error("Black Rose Room missing from rooms[]");
  const blackName = centerList.splice(brIndex,1)[0];
  roomByPos.set(key(0,0), {name: blackName, color:'black'});

  // throne:
  const thronePool = pools['purple'] || [];
  const throneIndex = thronePool.findIndex(n => n.endsWith("#2"));
  if (throneIndex === -1) throw new Error("Throne Room|purple missing from rooms[]");
  const throneName = thronePool.splice(throneIndex,1)[0];
  roomByPos.set(throneKey, {name: throneName, color:'purple'});

  // now for remaining colorMap positions, distribute randomly from pools
  // build list of positions (excluding center and throne)
  const remainingPositions = [...colorMap.keys()].filter(k => k !== key(0,0) && k !== throneKey);
  shuffle(remainingPositions);

  // shuffle pools
  for (const c of Object.keys(pools)) shuffle(pools[c]);

  for (const pos of remainingPositions){
    const color = colorMap.get(pos);
    if (!pools[color] || pools[color].length === 0) {
      throw new Error(`Not enough rooms available for color ${color} while mapping.`);
    }
    const name = pools[color].pop();
    roomByPos.set(pos, {name, color});
  }
  return roomByPos;
}

/* ===== Main generator that ties everything together ===== */
function generateValidLodge(){
  var rendered = false;
  var shape;
  var fullSet;
  var candidates;
  var removePairsNeeded;
  
  while(!rendered) {
    
    fullSet = buildFullSet(); // 37 keys
    candidates = buildCandidatePairs(fullSet); // ~15 pairs
    removePairsNeeded = (fullSet.size - 19) / 2; // should be 9

  // Try candidate combinations; search returns a shapeSet or null
    shape = chooseRemovalPairCombination(fullSet, candidates, removePairsNeeded);
  if (shape) rendered =true;//throw new Error("Failed to find a symmetric removal combination that satisfies graph constraints.");
  }
  
  // Choose random throne key from ring 1 (central ring intact)
  const ring1 = ringKeys(1);
  const throneKey = ring1[Math.floor(Math.random()*ring1.length)];

  // ensure throneKey is present in shape (ring1 is never removed, so yes)
  if (!shape.has(throneKey)) throw new Error("Chosen throneKey missing from shape — shouldn't happen.");

  // Now assign colors to shape (backtracking)
  const colorMap = assignColorsToShape(shape, throneKey);
  if (!colorMap) throw new Error("Failed to color the chosen shape under adjacency and count constraints.");

  // map room names to positions (ensuring black and throne rooms placed exactly)
  const roomPositionMap = mapRoomsToPositions(colorMap, throneKey);
  return { fullSet, shape, colorMap, roomPositionMap, throneKey };
}

/* ======== Rendering ======= */
var board = document.getElementById('board');

function renderLodge(lodge){
  board = document.getElementById("board");
	
  board.innerHTML = '';

	const refreshBtn = document.createElement("button");
    refreshBtn.textContent = "🔄 Refresh Board";
    refreshBtn.style.marginTop = "10px";
    refreshBtn.onclick = () => createAndRender();
    board.appendChild(refreshBtn);
	
  const {fullSet, shape, roomPositionMap, throneKey} = lodge;

  // compute pixel positions and bounding box
  const pts = [...fullSet].map(k => {
    const {q,r} = unkey(k);
    const p = axialToPixel(q,r);
    return {k, q, r, x:p.x, y:p.y};
  });
  const minX = Math.min(...pts.map(p => p.x));
  const maxX = Math.max(...pts.map(p => p.x));
  const minY = Math.min(...pts.map(p => p.y));
  const maxY = Math.max(...pts.map(p => p.y));

  const groupW = (maxX - minX) + HEX_W;
  const groupH = (maxY - minY) + HEX_H;
  const offsetX = (board.clientWidth - groupW)/2 - minX;
  const offsetY = (board.clientHeight - groupH)/2 - minY;

  for (const p of pts){
    const posKey = p.k;
    const room = roomPositionMap.get(posKey);
    const div = document.createElement('div');

    if(room) {
    div.className = `hex ${room.color}` + (posKey === throneKey ? ' throne' : '');
    div.style.left = `${Math.round(p.x + offsetX)}px`;
    div.style.top  = `${Math.round(p.y + offsetY)}px`;
    const lbl = document.createElement('div');
    lbl.className = 'label';
    lbl.textContent = room.name.includes("#") ? room.name.split("#")[0] : room.name;
    div.appendChild(lbl);
    board.appendChild(div);
    } else {
      //alert("Loop: ");
        if (axialDistance({q:p.q,r:p.r},{q:0,r:0}) === 3) {

          let neighborsPresent = 0;
          for (const [nq,nr] of neighbors(p.q,p.r)){
            const nk = key(nq,nr);
            if (roomPositionMap.has(nk)) neighborsPresent++;
          }

          if(neighborsPresent>=2) {  
            
            div.style.left = `${Math.round(p.x + offsetX)}px`;
            div.style.top  = `${Math.round(p.y + offsetY)}px`;
            div.className = 'hex empty';
            const lbl = document.createElement('div');
            lbl.className = 'label';
            lbl.textContent = 'X';
            div.appendChild(lbl);
            board.appendChild(div);
          }
        }
    }
  }
}

/* ===== randomize helper ===== */
function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* ===== initial render & regen button ===== */
function createAndRender(){
  try {
    const lodge = generateValidLodge();
    renderLodge(lodge);  
  } catch (e) {
    alert("Show Lodge module error: " + e.message);
    console.error(e);
  }
}
		
// document.getElementById('regen').addEventListener('click', createAndRender);
// createAndRender();
		
    </script>

    <body onload="ruleTip()">
			<h1>Black Rose Wars - Random Setup</h1>
        	<div id="result">
        	</div>
			<hr>
		
			<!-- Error messages area -->
			<div id="error-messages"
     			role="alert"
    			aria-live="polite"
     			class="error hidden">
  				<!-- Errors will be injected here -->
			</div>
		
			<b>Select the core boxes and expansions for your Setup:</b><p>
	<div style='padding-left:20px;'>

	<input type="checkbox" id="SCENARIO" name="SCENARIO" value="SCENARIO" checked><label for="SCENARIO"> Scenario</label><br>
	<input type="checkbox" id="SCHOOL" name="SCHOOL" value="SCHOOL" checked><label for="SCHOOL"> Schools</label> &nbsp;&nbsp;
	<input type="checkbox" id="PLAYER" name="PLAYER" value="PLAYER" checked><label for="PLAYER"> Start Player</label> &nbsp;&nbsp;
	<input type="checkbox" id="MAGE" name="MAGE" value="MAGE" checked><label for="MAGE"> Mages</label> &nbsp;&nbsp;
	<input type="checkbox" id="LODGE" name="LODGE" value="LODGE" checked><label for="LODGE"> Lodge</label> &nbsp;&nbsp;
	<input type="checkbox" id="AVATAR" name="AVATAR" value="AVATAR" checked><label for="AVATAR"> Avatar</label>
	<p>
		
	<table><tr><td VALIGN=TOP> 
			<input type="checkbox" id="BRW-R-CORE" name="BRW-R-CORE" value="BRW-R-CORE" checked>
         <label for="BRW-R-CORE"> Rebirth Core</label><br>

			<input type="checkbox" id="BRW-R-ROTAS" name="BRW-R-ROTAS" value="BRW-R-ROTAS" checked>
         <label for="BRW-R-ROTAS"> Rebirth ROTAS</label><br>
		
			<input type="checkbox" id="BRW-R-CORE-DM" name="BRW-R-CORE-DM" value="BRW-R-CORE-DM" checked>
         <label for="BRW-R-CORE-DM"> Rebirth Deadly Masks</label><br>

			<input type="checkbox" id="BRW-R-IRENE" name="BRW-R-IRENE" value="BRW-R-IRENE">
         <label for="BRW-R-IRENE"> Rebirth Irene's Quest</label><br>
		
			<input type="checkbox" id="BRW-R-APO" name="BRW-R-APO" value="BRW-R-APO">
         <label for="BRW-R-APO"> Rebirth Apocalypse</label><br>

			<input type="checkbox" id="BRW-R-FORGE" name="BRW-R-FORGE" value="BRW-R-FORGE">
         <label for="BRW-R-FORGE"> Rebirth Dread Forge</label><br>

			<input type="checkbox" id="BRW-R-GAEA" name="BRW-R-GAEA" value="BRW-R-GAEA">
         <label for="BRW-R-GAEA"> Rebirth Gaea Reborn</label><br>	

			<input type="checkbox" id="BRW-R-SOF" name="BRW-R-SOF" value="BRW-R-SOF">
         <label for="BRW-R-SOF"> Rebirth Seal of Fire</label><br>

	</td><td VALIGN=TOP>
			<input type="checkbox" id="DUEL-LEX" name="DUEL-LEX" value="DUEL-LEX">
         <label for="DUEL-LEX"> Duel Lex</label><br>

			<input type="checkbox" id="DUEL-VOID" name="DUEL-VOID" value="DUEL-VOID">
         <label for="DUEL-VOID"> Duel Void</label><p>

			<input type="checkbox" id="BRW-CORE" name="BRW-CORE" value="BRW-CORE">
         <label for="BRW-CORE"> BRW Core (OG)</label><br>

			<input type="checkbox" id="BRW-SATOR" name="BRW-SATOR" value="BRW-SATOR">
         <label for="BRW-SATOR"> BRW SATOR</label><br>
		
			<input type="checkbox" id="BRW-CORE-HT" name="BRW-CORE-HT" value="BRW-CORE-HT">
         <label for="BRW-CORE-HT"> BRW Hidden Thorns</label><br>

			<input type="checkbox" id="BRW-INFERNO" name="BRW-INFERNO" value="BRW-INFERNO">
         <label for="BRW-INFERNO"> BRW Inferno</label><br>
		 
			<input type="checkbox" id="BRW-CRONO" name="BRW-CRONO" value="BRW-CRONO">
         <label for="BRW-CRONO"> BRW Crono</label><br>
		 
			<input type="checkbox" id="BRW-FAMILIARS" name="BRW-FAMILIARS" value="BRW-FAMILIARS">
         <label for="BRW-FAMILIARS"> BRW Familiars</label><br>
	</td><td VALIGN=TOP>
		 	<input type="checkbox" id="ASHES" name="ASHES" value="ASHES">
         <label for="ASHES"> Ashes Magazine</label><br>

		 	<input type="checkbox" id="NA" name="NA" value="NA">
         <label for="NA"> Nova Aetas Crossover</label><br>
		 
		 	<input type="checkbox" id="REQ" name="REQ" value="REQ">
         <label for="REQ"> Requiem Crossover</label><p>

		 	<input type="checkbox" id="BRW-REV-CORE" name="BRW-REV-CORE" value="BRW-REV-CORE">
         <label for="BRW-REV-CORE"> Revised Core (REV)</label><br>

		 	<input type="checkbox" id="BRW-REV-TENET" name="BRW-REV-TENET" value="BRW-REV-TENET">
         <label for="BRW-REV-TENET"> Revised TENET</label><br>

			<input type="checkbox" id="BRW-REV-CORE-HT" name="BRW-REV-CORE-HT" value="BRW-REV-CORE-HT">
         <label for="BRW-REV-CORE-HT"> Revised Hidden Thorns</label><p> 
		 
			<input type="checkbox" id="BRW-REB-CUSTCONV" name="BRW-REB-CUSTCONV" value="BRW-REB-CUSTCONV">
         <label for="BRW-REB-CUSTCONV"> Rebirth Custom Conversion Kit (CCK)</label><br> 

		 	<input type="checkbox" id="BRW-DISCORD" name="BRW-DISCORD" value="BRW-DISCORD">
         <label for="BRW-DISCORD"> Discord Custom Items</label><br> 	 

	</td></tr></table>
	
         <p>
        	<button onclick="displayLibrary();">Get me my random Setup!</button><p>
				
	</div>

			<hr><p>
			<b>A ton of helpful or even essential material and information for BRW Rebirth created by me:</b><br>
			<ul>
			<li><a href="https://boardgamegeek.com/thread/3231567/torns-brwr-overview-and-other-useful-files-german">TORN's BRW Rebirth overview and many useful files (German / English)</a></li>
			
			<li><a href="https://boardgamegeek.com/thread/3480476/46-rules-you-may-have-missed-in-brw-rebirth">46 rules you may have missed in BRW Rebirth</a></li>
			
			<li><a href="https://boardgamegeek.com/thread/3263754/strength-and-complexity-of-schools">Strength and complexity of BRW Rebirth schools</a></li>

			<!--li><a href="BRW-R%20Mage%20Avatars%20Supplement%20v1%202025-08-09.pdf">Mage Avatars v1 (draft)</a></li><-->
			</ul>
				
			<p>Content & programmed by TORN@BGG

    </body>
</html>
