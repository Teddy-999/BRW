<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Symmetrical Lodge Generator</title>
<style>
  body {
    background-color: #222;
    color: white;
    text-align: center;
    font-family: sans-serif;
  }
  canvas {
    background-color: #333;
    margin-top: 20px;
  }
</style>
</head>
<body>
<h1>Random Symmetrical Lodge</h1>
<canvas id="lodgeCanvas" width="1000" height="1000"></canvas>

<script>
// ======== ROOM DATA (placeholder names, replace with real ones) ========
let rooms = [
  "Black Rose Room|black",
  "Throne Room|purple", "Chamber of Whispers|purple", "Hall of Crowns|purple",
  "Inferno Hall|red", "Ember Chamber|red", "Blood Furnace|red",
  "Emerald Vault|green", "Jade Garden|green", "Venom Hall|green",
  "Sapphire Hall|blue", "Ocean Chamber|blue", "Frozen Court|blue",
  "Steel Bastion|gray", "Iron Workshop|gray", "Shadow Forge|gray",
  "Sun Hall|yellow", "Golden Dome|yellow", "Amber Court|yellow"
];

// ======== HEX HELPERS ========
const HEX_SIZE = 50 * 1.3; // +30% size
const SQRT3 = Math.sqrt(3);

function hexToPixel(q, r) {
  let x = HEX_SIZE * (SQRT3 * q + SQRT3/2 * r);
  let y = HEX_SIZE * (3/2 * r);
  return {x, y};
}

function getNeighbors(q, r) {
  return [
    {q: q+1, r: r}, {q: q-1, r: r},
    {q: q,   r: r+1}, {q: q,   r: r-1},
    {q: q+1, r: r-1}, {q: q-1, r: r+1}
  ];
}

// ======== GRAPH CHECKS ========
function isConnected(tiles) {
  let keys = Object.keys(tiles);
  if (!keys.length) return true;
  let visited = new Set();
  let stack = [keys[0]];
  while (stack.length) {
    let node = stack.pop();
    if (!visited.has(node)) {
      visited.add(node);
      let [q, r] = node.split(',').map(Number);
      for (let n of getNeighbors(q, r)) {
        let k = `${n.q},${n.r}`;
        if (tiles[k] && !visited.has(k)) stack.push(k);
      }
    }
  }
  return visited.size === keys.length;
}

function isBiconnected(tiles, centerKey) {
  let keys = Object.keys(tiles);
  for (let key of keys) {
    if (key === centerKey) continue;
    let tempTiles = {...tiles};
    delete tempTiles[key];
    if (!isConnected(tempTiles)) return false;
  }
  return true;
}

// ======== GENERATE LODGE SHAPE ========
function generateShape() {
  let tiles = {};
  const RADIUS = 3;
  for (let q = -RADIUS; q <= RADIUS; q++) {
    for (let r = -RADIUS; r <= RADIUS; r++) {
      let s = -q - r;
      if (Math.abs(q) <= RADIUS && Math.abs(r) <= RADIUS && Math.abs(s) <= RADIUS) {
        tiles[`${q},${r}`] = true;
      }
    }
  }

  let centerKey = "0,0";
  let centralRing = getNeighbors(0,0).map(n => `${n.q},${n.r}`);
  let targetCount = rooms.length;

  let removable = Object.keys(tiles).filter(k => k !== centerKey && !centralRing.includes(k));
  let removablePairs = [];
  for (let key of removable) {
    let [q,r] = key.split(',').map(Number);
    let mirror = `${-q},${-r}`;
    if (tiles[mirror] && key < mirror) removablePairs.push([key, mirror]);
  }

  while (Object.keys(tiles).length > targetCount && removablePairs.length > 0) {
    let idx = Math.floor(Math.random() * removablePairs.length);
    let [a, b] = removablePairs[idx];
    let tempTiles = {...tiles};
    delete tempTiles[a];
    delete tempTiles[b];
    if (isConnected(tempTiles) && isBiconnected(tempTiles, centerKey)) {
      delete tiles[a];
      delete tiles[b];
      removablePairs = removablePairs.filter(p => p[0] !== a && p[1] !== a && p[0] !== b && p[1] !== b);
    } else {
      removablePairs.splice(idx, 1);
    }
  }

  return tiles;
}

// ======== COLOR ASSIGNMENT ========
function assignColors(tiles) {
  let coords = Object.keys(tiles).map(k => {
    let [q,r] = k.split(',').map(Number);
    return {q,r,key:k,neighbors:getNeighbors(q,r).map(n => `${n.q},${n.r}`)};
  });

  let counts = {black:1, purple:3, red:3, green:3, blue:3, gray:3, yellow:3};
  let assignment = {};

  function backtrack(i) {
    if (i === coords.length) return true;
    let c = coords[i];
    let possibleColors = Object.keys(counts).filter(color => counts[color] > 0);

    // Black Rose Room in center
    if (c.key === "0,0") {
      assignment[c.key] = 'black';
      counts.black--;
      return backtrack(i+1);
    }

    // Throne Room in central ring
    let centralRing = getNeighbors(0,0).map(n => `${n.q},${n.r}`);
    if (c.key === thronePos) {
      if (counts.purple <= 0) return false;
      assignment[c.key] = 'purple';
      counts.purple--;
      return backtrack(i+1);
    }

    for (let color of possibleColors) {
      if (c.neighbors.some(n => assignment[n] === color)) continue;
      assignment[c.key] = color;
      counts[color]--;
      if (backtrack(i+1)) return true;
      counts[color]++;
      delete assignment[c.key];
    }
    return false;
  }

  return backtrack(0) ? assignment : null;
}

// ======== MAIN GENERATION ========
let shape, thronePos, colorMap;
while (true) {
  shape = generateShape();
  let centralRing = getNeighbors(0,0).map(n => `${n.q},${n.r}`);
  thronePos = centralRing[Math.floor(Math.random() * centralRing.length)];
  colorMap = assignColors(shape);
  if (colorMap) break;
}

// ======== DRAW ========
function drawHex(ctx, x, y, size, color, label) {
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    let angle = Math.PI/3 * i + Math.PI/6;
    let vx = x + size * Math.cos(angle);
    let vy = y + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(vx, vy);
    else ctx.lineTo(vx, vy);
  }
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = "#fff";
  ctx.font = "10px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(label, x, y+3);
}

let colorHex = {
  black: "#111", purple: "#800080", red: "#b00000",
  green: "#006400", blue: "#00008b", gray: "#555555", yellow: "#bdb76b"
};

let canvas = document.getElementById("lodgeCanvas");
let ctx = canvas.getContext("2d");
ctx.translate(canvas.width/2, canvas.height/2);

let roomByColor = {};
for (let room of rooms) {
  let [name,color] = room.split('|');
  if (!roomByColor[color]) roomByColor[color] = [];
  roomByColor[color].push(name);
}
for (let c in roomByColor) {
  shuffle(roomByColor[c]);
}

for (let key of Object.keys(shape)) {
  let [q,r] = key.split(',').map(Number);
  let {x,y} = hexToPixel(q,r);
  let color = colorMap[key];
  let name = roomByColor[color].pop();
  drawHex(ctx, x, y, HEX_SIZE, colorHex[color], name);
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
</script>
</body>
</html>
